<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: cs35l41_private_functions_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structcs35l41__private__functions__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cs35l41_private_functions_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Driver private API.  
 <a href="structcs35l41__private__functions__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cs35l41_8h_source.html">cs35l41.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae7ab34f9a1b2f9e40a0ebca901f54e20"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#ae7ab34f9a1b2f9e40a0ebca901f54e20">timer_callback</a> )(uint32_t status, void *cb_arg)</td></tr>
<tr class="memdesc:ae7ab34f9a1b2f9e40a0ebca901f54e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the driver when the BSP Timer expires.  <a href="structcs35l41__private__functions__t.html#ae7ab34f9a1b2f9e40a0ebca901f54e20">More...</a><br /></td></tr>
<tr class="separator:ae7ab34f9a1b2f9e40a0ebca901f54e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bf56df199d403c8089a887ea7f15cb"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#ad3bf56df199d403c8089a887ea7f15cb">cp_read_callback</a> )(uint32_t status, void *cb_arg)</td></tr>
<tr class="memdesc:ad3bf56df199d403c8089a887ea7f15cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the driver when the BSP Control Port (cp) read transaction completes.  <a href="structcs35l41__private__functions__t.html#ad3bf56df199d403c8089a887ea7f15cb">More...</a><br /></td></tr>
<tr class="separator:ad3bf56df199d403c8089a887ea7f15cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26ee752fa42934fe64e1c41de78fcd2"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#ab26ee752fa42934fe64e1c41de78fcd2">cp_write_callback</a> )(uint32_t status, void *cb_arg)</td></tr>
<tr class="memdesc:ab26ee752fa42934fe64e1c41de78fcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the driver when the BSP Control Port (cp) write transaction completes.  <a href="structcs35l41__private__functions__t.html#ab26ee752fa42934fe64e1c41de78fcd2">More...</a><br /></td></tr>
<tr class="separator:ab26ee752fa42934fe64e1c41de78fcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a86ca59f74869cb7d706000231b316"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#a00a86ca59f74869cb7d706000231b316">irq_callback</a> )(uint32_t status, void *cb_arg)</td></tr>
<tr class="memdesc:a00a86ca59f74869cb7d706000231b316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the driver when the CS35L41 INTb GPIO drops low.  <a href="structcs35l41__private__functions__t.html#a00a86ca59f74869cb7d706000231b316">More...</a><br /></td></tr>
<tr class="separator:a00a86ca59f74869cb7d706000231b316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ae1e868279c613f34736c20a45d4f5"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#ae6ae1e868279c613f34736c20a45d4f5">read_reg</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t addr, uint32_t *val, bool is_blocking)</td></tr>
<tr class="memdesc:ae6ae1e868279c613f34736c20a45d4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the contents of a single register/memory address.  <a href="structcs35l41__private__functions__t.html#ae6ae1e868279c613f34736c20a45d4f5">More...</a><br /></td></tr>
<tr class="separator:ae6ae1e868279c613f34736c20a45d4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4410e22074eeece6f37c48f8369067dd"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#a4410e22074eeece6f37c48f8369067dd">write_reg</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t addr, uint32_t val, bool is_blocking)</td></tr>
<tr class="memdesc:a4410e22074eeece6f37c48f8369067dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the contents of a single register/memory address.  <a href="structcs35l41__private__functions__t.html#a4410e22074eeece6f37c48f8369067dd">More...</a><br /></td></tr>
<tr class="separator:a4410e22074eeece6f37c48f8369067dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515d10603ab119e901e6f821c726363e"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#a515d10603ab119e901e6f821c726363e">reset_sm</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a515d10603ab119e901e6f821c726363e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset State Machine.  <a href="structcs35l41__private__functions__t.html#a515d10603ab119e901e6f821c726363e">More...</a><br /></td></tr>
<tr class="separator:a515d10603ab119e901e6f821c726363e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae268af039a2d1efe43d7d02f79a55aef"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#ae268af039a2d1efe43d7d02f79a55aef">boot_sm</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:ae268af039a2d1efe43d7d02f79a55aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot State Machine.  <a href="structcs35l41__private__functions__t.html#ae268af039a2d1efe43d7d02f79a55aef">More...</a><br /></td></tr>
<tr class="separator:ae268af039a2d1efe43d7d02f79a55aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d36b513f6e33a55fa8806cd85f7e17"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#ad5d36b513f6e33a55fa8806cd85f7e17">power_up_sm</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:ad5d36b513f6e33a55fa8806cd85f7e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power Up State Machine.  <a href="structcs35l41__private__functions__t.html#ad5d36b513f6e33a55fa8806cd85f7e17">More...</a><br /></td></tr>
<tr class="separator:ad5d36b513f6e33a55fa8806cd85f7e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11935704b9da56c6e6fc2e79858ac41"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#aa11935704b9da56c6e6fc2e79858ac41">power_down_sm</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:aa11935704b9da56c6e6fc2e79858ac41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power Down State Machine.  <a href="structcs35l41__private__functions__t.html#aa11935704b9da56c6e6fc2e79858ac41">More...</a><br /></td></tr>
<tr class="separator:aa11935704b9da56c6e6fc2e79858ac41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7deba30ac02db83cb86450d42b7afb02"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#a7deba30ac02db83cb86450d42b7afb02">configure_sm</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a7deba30ac02db83cb86450d42b7afb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure State Machine.  <a href="structcs35l41__private__functions__t.html#a7deba30ac02db83cb86450d42b7afb02">More...</a><br /></td></tr>
<tr class="separator:a7deba30ac02db83cb86450d42b7afb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5875bc5a1914e54b4eb326ea9190bb"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#adf5875bc5a1914e54b4eb326ea9190bb">field_access_sm</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:adf5875bc5a1914e54b4eb326ea9190bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Field Access State Machine.  <a href="structcs35l41__private__functions__t.html#adf5875bc5a1914e54b4eb326ea9190bb">More...</a><br /></td></tr>
<tr class="separator:adf5875bc5a1914e54b4eb326ea9190bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a64f0be724b6bfc6231d9086db14035"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#a7a64f0be724b6bfc6231d9086db14035">calibration_sm</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a7a64f0be724b6bfc6231d9086db14035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibration State Machine.  <a href="structcs35l41__private__functions__t.html#a7a64f0be724b6bfc6231d9086db14035">More...</a><br /></td></tr>
<tr class="separator:a7a64f0be724b6bfc6231d9086db14035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4b69bda2f1c574d0901b1120030a1a"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#a5e4b69bda2f1c574d0901b1120030a1a">get_dsp_status_sm</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a5e4b69bda2f1c574d0901b1120030a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DSP Status State Machine.  <a href="structcs35l41__private__functions__t.html#a5e4b69bda2f1c574d0901b1120030a1a">More...</a><br /></td></tr>
<tr class="separator:a5e4b69bda2f1c574d0901b1120030a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408ac75036fa1520638b85416fafd87e"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#a408ac75036fa1520638b85416fafd87e">event_sm</a> )(void *driver)</td></tr>
<tr class="memdesc:a408ac75036fa1520638b85416fafd87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event Handler State Machine.  <a href="structcs35l41__private__functions__t.html#a408ac75036fa1520638b85416fafd87e">More...</a><br /></td></tr>
<tr class="separator:a408ac75036fa1520638b85416fafd87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaea1ee93a697281e0de22c40f67c61f"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#afaea1ee93a697281e0de22c40f67c61f">get_errata</a> )(uint32_t devid, uint32_t revid, const uint32_t **errata)</td></tr>
<tr class="memdesc:afaea1ee93a697281e0de22c40f67c61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointer to correct errata based on DEVID/REVID.  <a href="structcs35l41__private__functions__t.html#afaea1ee93a697281e0de22c40f67c61f">More...</a><br /></td></tr>
<tr class="separator:afaea1ee93a697281e0de22c40f67c61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef244557503ba25c60a8c55efab9143"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#a6ef244557503ba25c60a8c55efab9143">cp_bulk_read</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t addr, uint32_t length)</td></tr>
<tr class="memdesc:a6ef244557503ba25c60a8c55efab9143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads contents from a consecutive number of memory addresses.  <a href="structcs35l41__private__functions__t.html#a6ef244557503ba25c60a8c55efab9143">More...</a><br /></td></tr>
<tr class="separator:a6ef244557503ba25c60a8c55efab9143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed22cf9c3bbf114381a09ff71ce3e83f"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#aed22cf9c3bbf114381a09ff71ce3e83f">cp_bulk_write</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t addr, uint8_t *bytes, uint32_t length)</td></tr>
<tr class="memdesc:aed22cf9c3bbf114381a09ff71ce3e83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes from byte array to consecutive number of Control Port memory addresses.  <a href="structcs35l41__private__functions__t.html#aed22cf9c3bbf114381a09ff71ce3e83f">More...</a><br /></td></tr>
<tr class="separator:aed22cf9c3bbf114381a09ff71ce3e83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ee2745d3513222d4681c7d5009569a"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#a28ee2745d3513222d4681c7d5009569a">apply_trim_word</a> )(uint8_t *otp_mem, uint32_t bit_count, uint32_t *reg_val, uint32_t shift, uint32_t size)</td></tr>
<tr class="memdesc:a28ee2745d3513222d4681c7d5009569a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies OTP trim bit-field to current register word value.  <a href="structcs35l41__private__functions__t.html#a28ee2745d3513222d4681c7d5009569a">More...</a><br /></td></tr>
<tr class="separator:a28ee2745d3513222d4681c7d5009569a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacffd3273ff8f45695820f102fd75c72"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#aacffd3273ff8f45695820f102fd75c72">is_mbox_status_correct</a> )(uint32_t cmd, uint32_t status)</td></tr>
<tr class="memdesc:aacffd3273ff8f45695820f102fd75c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check HALO MBOX Status against the MBOX Command sent.  <a href="structcs35l41__private__functions__t.html#aacffd3273ff8f45695820f102fd75c72">More...</a><br /></td></tr>
<tr class="separator:aacffd3273ff8f45695820f102fd75c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9fe55eb9babd92801872db7df24b8f"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#a3a9fe55eb9babd92801872db7df24b8f">validate_boot_config</a> )(<a class="el" href="structcs35l41__boot__config__t.html">cs35l41_boot_config_t</a> *config, bool is_fw_boot, bool is_coeff_boot)</td></tr>
<tr class="memdesc:a3a9fe55eb9babd92801872db7df24b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the boot configuration provided by the BSP.  <a href="structcs35l41__private__functions__t.html#a3a9fe55eb9babd92801872db7df24b8f">More...</a><br /></td></tr>
<tr class="separator:a3a9fe55eb9babd92801872db7df24b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73dfdbfb9c0ba6a983e7614dc80ecce"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#ae73dfdbfb9c0ba6a983e7614dc80ecce">control_q_copy</a> )(void *from, void *to)</td></tr>
<tr class="memdesc:ae73dfdbfb9c0ba6a983e7614dc80ecce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements 'copy' method for Control Request Queue contents.  <a href="structcs35l41__private__functions__t.html#ae73dfdbfb9c0ba6a983e7614dc80ecce">More...</a><br /></td></tr>
<tr class="separator:ae73dfdbfb9c0ba6a983e7614dc80ecce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8fe12fe7a6b0720da627aaa36cf4fa"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#a1d8fe12fe7a6b0720da627aaa36cf4fa">is_control_valid</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a1d8fe12fe7a6b0720da627aaa36cf4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the currently processed Control Request is valid for the current state of the driver.  <a href="structcs35l41__private__functions__t.html#a1d8fe12fe7a6b0720da627aaa36cf4fa">More...</a><br /></td></tr>
<tr class="separator:a1d8fe12fe7a6b0720da627aaa36cf4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07eeca75abaca69acc316d0591527a0"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#aa07eeca75abaca69acc316d0591527a0">load_control</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:aa07eeca75abaca69acc316d0591527a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load new Control Request to be processed.  <a href="structcs35l41__private__functions__t.html#aa07eeca75abaca69acc316d0591527a0">More...</a><br /></td></tr>
<tr class="separator:aa07eeca75abaca69acc316d0591527a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c9558d529a5b92507dda7f770e8941"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#a90c9558d529a5b92507dda7f770e8941">irq_to_event_id</a> )(uint32_t *<a class="el" href="cs35l41_8c.html#a93ed7ca914fe1948b5d02bdf1b1c0083">irq_statuses</a>)</td></tr>
<tr class="memdesc:a90c9558d529a5b92507dda7f770e8941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps IRQ Flag to Event ID passed to BSP.  <a href="structcs35l41__private__functions__t.html#a90c9558d529a5b92507dda7f770e8941">More...</a><br /></td></tr>
<tr class="separator:a90c9558d529a5b92507dda7f770e8941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70a8fb4d21e55478f1b1bcb2708ef8b"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#ad70a8fb4d21e55478f1b1bcb2708ef8b">apply_configs</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:ad70a8fb4d21e55478f1b1bcb2708ef8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply all driver one-time configurations to corresponding Control Port register/memory addresses.  <a href="structcs35l41__private__functions__t.html#ad70a8fb4d21e55478f1b1bcb2708ef8b">More...</a><br /></td></tr>
<tr class="separator:ad70a8fb4d21e55478f1b1bcb2708ef8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a23b8eb3c811aba012b87508006b93"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__private__functions__t.html#a87a23b8eb3c811aba012b87508006b93">is_mixer_source_used</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint8_t source)</td></tr>
<tr class="memdesc:a87a23b8eb3c811aba012b87508006b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks all hardware mixer source selections for a specific source.  <a href="structcs35l41__private__functions__t.html#a87a23b8eb3c811aba012b87508006b93">More...</a><br /></td></tr>
<tr class="separator:a87a23b8eb3c811aba012b87508006b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Driver private API. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="ad70a8fb4d21e55478f1b1bcb2708ef8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70a8fb4d21e55478f1b1bcb2708ef8b">&#9670;&nbsp;</a></span>apply_configs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::apply_configs) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply all driver one-time configurations to corresponding Control Port register/memory addresses. </p>
<p>Performs the following:</p><ul>
<li>applies all configurations from <a class="el" href="structcs35l41__audio__config__t.html" title="Collection of audio-related configurations.">cs35l41_audio_config_t</a></li>
<li>applies all configurations from <a class="el" href="structcs35l41__amp__config__t.html" title="Amplifier-related configurations.">cs35l41_amp_config_t</a></li>
<li>based on configurations, sets/clears hardware block enables</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if any configuration parameters are outside bounds or do not result in proper register bit-field encoding</li>
<li>CS35L41_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a28ee2745d3513222d4681c7d5009569a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ee2745d3513222d4681c7d5009569a">&#9670;&nbsp;</a></span>apply_trim_word</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::apply_trim_word) (uint8_t *otp_mem, uint32_t bit_count, uint32_t *reg_val, uint32_t shift, uint32_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies OTP trim bit-field to current register word value. </p>
<p>During the Reset SM, trim bit-fields must be tweezed from OTP and applied to corresponding Control Port register contents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otp_mem</td><td>pointer byte array consisting of entire contents of OTP </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit_count</td><td>current bit index into otp_mem, i.e. location of bit-field in OTP memory </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">reg_val</td><td>contents of register to modify with trim bit-field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shift</td><td>location of bit-field in control port register in terms of bits from bit 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of bit-field in bits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if any pointers are NULL or if the bit-field size is 0</li>
<li>CS35L41_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae268af039a2d1efe43d7d02f79a55aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae268af039a2d1efe43d7d02f79a55aef">&#9670;&nbsp;</a></span>boot_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::boot_sm) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boot State Machine. </p>
<p>This state machine loads FW and COEFF images into the CS35L41 HALO DSP memory regions. Completing the state machine results in the driver transition to DSP_STANDBY state. The state machine design is documented in the Boot State Diagram found in the Driver Tech Note.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS35L41_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Boot State Diagram </dd></dl>

</div>
</div>
<a id="a7a64f0be724b6bfc6231d9086db14035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a64f0be724b6bfc6231d9086db14035">&#9670;&nbsp;</a></span>calibration_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::calibration_sm) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calibration State Machine. </p>
<p>This state machine performs the Calibration sequence required for CSPL HALO DSP firmware Protect Algorithm. Completing the state machine does not result in any driver state change. The state machine design is documented in the Calibration State Diagram found in the Driver Tech Note.</p>
<dl class="section attention"><dt>Attention</dt><dd>The Calibration sequence can only be successfully performed under the following conditions:<ul>
<li>while the driver is in POWER_UP state</li>
<li>after HALO DSP FW and Calibration COEFF has been loaded</li>
<li>while the ASP is clocked with valid I2S clocks</li>
<li>while the ASP is being sourced with Silence</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS35L41_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Calibration State Diagram </dd>
<dd>
<a class="el" href="structcs35l41__calibration__t.html" title="State of HALO FW Calibration.">cs35l41_calibration_t</a> </dd></dl>

</div>
</div>
<a id="a7deba30ac02db83cb86450d42b7afb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7deba30ac02db83cb86450d42b7afb02">&#9670;&nbsp;</a></span>configure_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::configure_sm) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure State Machine. </p>
<p>This state machine performs all CS35L41 configuration required after Reset (and DSP Boot, if required). Completing the state machine does not result in any driver state change. Although the configuration should almost always be performed when the driver is in STANDBY or DSP_STANDBY state, it is not prohibited. The state machine design is documented in the Configure State Diagram found in the Driver Tech Note.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS35L41_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Configure State Diagram </dd>
<dd>
<a class="el" href="cs35l41_8c.html#a4d0b0b678346b30ba3f1d06bddf4c52a" title="Apply all driver one-time configurations to corresponding Control Port register/memory addresses.">cs35l41_apply_configs()</a> </dd></dl>

</div>
</div>
<a id="ae73dfdbfb9c0ba6a983e7614dc80ecce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73dfdbfb9c0ba6a983e7614dc80ecce">&#9670;&nbsp;</a></span>control_q_copy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* cs35l41_private_functions_t::control_q_copy) (void *from, void *to)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements 'copy' method for Control Request Queue contents. </p>
<p>Initialization of <a class="el" href="structf__queue__t.html" title="Queue handling data structure.">f_queue_t</a> requires a 'copy' method for copying the data type that comprises the elements of the queue. This implements the method for the queue used for Control Requests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>pointer to element to copy contents from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>pointer of empty element to which the contents should be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>false if either pointers are null</li>
<li>true otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="f__queue_8h.html#abedd0d023ee1ed717ab173baae6a2d3b" title="Abstract method for copying from one queue element type to another.">f_queue_copy</a> </dd>
<dd>
<a class="el" href="structf__queue__if__t.html" title="Fixed Queue public API.">f_queue_if_t</a> member initialize </dd></dl>

</div>
</div>
<a id="a6ef244557503ba25c60a8c55efab9143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef244557503ba25c60a8c55efab9143">&#9670;&nbsp;</a></span>cp_bulk_read</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::cp_bulk_read) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t addr, uint32_t length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads contents from a consecutive number of memory addresses. </p>
<p>Starting at 'addr', this will read 'length' number of 32-bit values into the BSP-allocated buffer from the control port. This bulk read will place contents into the BSP buffer starting at the 4th byte address. Bytes 0-3 in the buffer are reserved for non-bulk reads (i.e. calls to cs35l41_read_reg). This control port call only supports non-blocking calls. This function also only supports I2C transactions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>32-bit address to be read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>number of memory addresses (i.e. 32-bit words) to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if the call to BSP failed, or if 'length' exceeds the size of BSP buffer</li>
<li>CS35L41_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Contains platform-dependent code. </dd></dl>

</div>
</div>
<a id="aed22cf9c3bbf114381a09ff71ce3e83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed22cf9c3bbf114381a09ff71ce3e83f">&#9670;&nbsp;</a></span>cp_bulk_write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::cp_bulk_write) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t addr, uint8_t *bytes, uint32_t length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes from byte array to consecutive number of Control Port memory addresses. </p>
<p>This control port call only supports non-blocking calls. This function also only supports I2C transactions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>32-bit address to be read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>pointer to array of bytes to write via Control Port bus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if the call to BSP failed</li>
<li>CS35L41_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Contains platform-dependent code. </dd></dl>

</div>
</div>
<a id="ad3bf56df199d403c8089a887ea7f15cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bf56df199d403c8089a887ea7f15cb">&#9670;&nbsp;</a></span>cp_read_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* cs35l41_private_functions_t::cp_read_callback) (uint32_t status, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the driver when the BSP Control Port (cp) read transaction completes. </p>
<p>This callback is given as a parameter for all non-blocking calls to the following API in <a class="el" href="structbsp__driver__if__t.html" title="BSP-to-Driver public API.">bsp_driver_if_t</a>.</p><ul>
<li>i2c_read_repeated_start</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Currently, the BSP and driver only support I2C transactions.</dd></dl>
<p>The primary task of this callback is to set flags in either the flag cache for the currently processed Control Request state machine, or the Event Handler state machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Status of the asynchronous call to BSP Control Port read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>A pointer to callback argument registered. For the driver, this arg is used for a pointer to the driver state <a class="el" href="structcs35l41__t.html" title="Driver state data structure.">cs35l41_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structbsp__driver__if__t.html" title="BSP-to-Driver public API.">bsp_driver_if_t</a> member i2c_read_repeated_start. </dd>
<dd>
<a class="el" href="bsp__driver__if_8h.html#a9da53d6fb2687f1afc4fe77a6d1a101f" title="Callback type for BSP-to-Driver callbacks.">bsp_callback_t</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Contains platform-dependent code. </dd></dl>

</div>
</div>
<a id="ab26ee752fa42934fe64e1c41de78fcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26ee752fa42934fe64e1c41de78fcd2">&#9670;&nbsp;</a></span>cp_write_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* cs35l41_private_functions_t::cp_write_callback) (uint32_t status, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the driver when the BSP Control Port (cp) write transaction completes. </p>
<p>This callback is given as a parameter for all non-blocking calls to the following API in <a class="el" href="structbsp__driver__if__t.html" title="BSP-to-Driver public API.">bsp_driver_if_t</a>.</p><ul>
<li>i2c_write</li>
<li>i2c_db_write</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Currently, the BSP and driver only support I2C transactions.</dd></dl>
<p>The primary task of this callback is to set flags in either the flag cache for the currently processed Control Request state machine, or the Event Handler state machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Status of the asynchronous call to BSP Control Port write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>A pointer to callback argument registered. For the driver, this arg is used for a pointer to the driver state <a class="el" href="structcs35l41__t.html" title="Driver state data structure.">cs35l41_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structbsp__driver__if__t.html" title="BSP-to-Driver public API.">bsp_driver_if_t</a> member i2c_write, i2c_db_write. </dd>
<dd>
<a class="el" href="bsp__driver__if_8h.html#a9da53d6fb2687f1afc4fe77a6d1a101f" title="Callback type for BSP-to-Driver callbacks.">bsp_callback_t</a> </dd></dl>

</div>
</div>
<a id="a408ac75036fa1520638b85416fafd87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408ac75036fa1520638b85416fafd87e">&#9670;&nbsp;</a></span>event_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::event_sm) (void *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event Handler State Machine. </p>
<p>This state machine performs all steps to handle IRQ and other asynchronous events the driver is aware of, resulting in calling of the notification callback (cs35l41_notification_callback_t).</p>
<p>Beginning the state machine results in transition of driver <b>mode</b> from HANDLING_CONTROLS to HANDLING_EVENTS, while completing the state machine will result in transition of driver <b>mode</b> from HANDLING_EVENTS to HANDLING_CONTROLS in <a class="el" href="cs35l41_8c.html#a9035b122e866a3ee7ae60c00fd1cebb1" title="Processes driver state machines.">cs35l41_process()</a>. The state machine design is documented in the Event Handler State Diagram found in the Driver Tech Note.</p>
<p>If there are any IRQ events that include Speaker-Safe Mode Errors or Boost-related events, then the procedure outlined in the Datasheet Section 4.16.1.1 is implemented here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS35L41_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Event Handler State Diagram </dd>
<dd>
<a class="el" href="cs35l41_8h.html#a342b87a54a7c071cdd662fe43506d6a8" title="Function pointer to Notification Callback.">cs35l41_notification_callback_t</a> </dd></dl>

</div>
</div>
<a id="adf5875bc5a1914e54b4eb326ea9190bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5875bc5a1914e54b4eb326ea9190bb">&#9670;&nbsp;</a></span>field_access_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::field_access_sm) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Field Access State Machine. </p>
<p>This state machine performs actions required to do a Get/Set of a Control Port register or HALO DSP Memory bit-field. Completing the state machine does not result in any driver state change. The state machine design is documented in the Field Access State Diagram found in the Driver Tech Note.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS35L41_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Field Access State Diagram </dd>
<dd>
<a class="el" href="structcs35l41__field__accessor__t.html" title="Data structure to describe a field to read via the Field Access SM.">cs35l41_field_accessor_t</a> </dd></dl>

</div>
</div>
<a id="a5e4b69bda2f1c574d0901b1120030a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4b69bda2f1c574d0901b1120030a1a">&#9670;&nbsp;</a></span>get_dsp_status_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::get_dsp_status_sm) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get DSP Status State Machine. </p>
<p>This state machine performs all register/memory field address reads to get the current HALO DSP status. Since some statuses are only determined by observing changes in values of a given field, the fields are read once, then after a delay of 10 milliseconds, are read a second time to observe changes. Completing the state machine does not result in any driver state change. The state machine design is documented in the Get DSP Status State Diagram found in the Driver Tech Note.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS35L41_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Get DSP Status State Diagram </dd>
<dd>
<a class="el" href="structcs35l41__dsp__status__t.html" title="Status of HALO FW.">cs35l41_dsp_status_t</a> </dd></dl>

</div>
</div>
<a id="afaea1ee93a697281e0de22c40f67c61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaea1ee93a697281e0de22c40f67c61f">&#9670;&nbsp;</a></span>get_errata</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::get_errata) (uint32_t devid, uint32_t revid, const uint32_t **errata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets pointer to correct errata based on DEVID/REVID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devid</td><td>DEVID read from CS35L41_SW_RESET_DEVID_REG </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">revid</td><td>REVID read from CS35L41_SW_RESET_REVID_REG </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errata</td><td>Pointer to array of uint32_t implementing errata</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL corresponding errata not found</li>
<li>CS35L41_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a00a86ca59f74869cb7d706000231b316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a86ca59f74869cb7d706000231b316">&#9670;&nbsp;</a></span>irq_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* cs35l41_private_functions_t::irq_callback) (uint32_t status, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the driver when the CS35L41 INTb GPIO drops low. </p>
<p>This callback is registered with the BSP in the register_gpio_cb() API call.</p>
<p>The primary task of this callback is to transition the driver mode from CS35L41_MODE_HANDLING_CONTROLS to CS35L41_MODE_HANDLING_EVENTS, in order to start processing the Event Handler state machine. It also resets the Event Handler state machine, if it was not currently being processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Status of the asynchronous call to BSP Control Port write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>A pointer to callback argument registered. For the driver, this arg is used for a pointer to the driver state <a class="el" href="structcs35l41__t.html" title="Driver state data structure.">cs35l41_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structbsp__driver__if__t.html" title="BSP-to-Driver public API.">bsp_driver_if_t</a> member register_gpio_cb. </dd>
<dd>
<a class="el" href="bsp__driver__if_8h.html#a9da53d6fb2687f1afc4fe77a6d1a101f" title="Callback type for BSP-to-Driver callbacks.">bsp_callback_t</a> </dd></dl>

</div>
</div>
<a id="a90c9558d529a5b92507dda7f770e8941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c9558d529a5b92507dda7f770e8941">&#9670;&nbsp;</a></span>irq_to_event_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::irq_to_event_id) (uint32_t *<a class="el" href="cs35l41_8c.html#a93ed7ca914fe1948b5d02bdf1b1c0083">irq_statuses</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps IRQ Flag to Event ID passed to BSP. </p>
<p>Allows for abstracting driver events relayed to BSP away from IRQ flags, to allow the possibility that multiple IRQ flags correspond to a single event to relay.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">irq_statuses</td><td>pointer to array of 32-bit words from IRQ1_IRQ1_EINT_*_REG registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32-bit word with CS35L41_EVENT_FLAG_* set for each event detected</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_s35_l41___e_v_e_n_t___f_l_a_g__.html" title="Flags passed to Notification Callback to notify BSP of specific driver events.">CS35L41_EVENT_FLAG_</a> </dd></dl>

</div>
</div>
<a id="a1d8fe12fe7a6b0720da627aaa36cf4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8fe12fe7a6b0720da627aaa36cf4fa">&#9670;&nbsp;</a></span>is_control_valid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::is_control_valid) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that the currently processed Control Request is valid for the current state of the driver. </p>
<p>Since the state of the driver is asynchronous to the Control Request currently being processed, cs35l41_process needs to check whether the request is valid for the current state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if no request is being processed, or if current request is invalid</li>
<li>CS35L41_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aacffd3273ff8f45695820f102fd75c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacffd3273ff8f45695820f102fd75c72">&#9670;&nbsp;</a></span>is_mbox_status_correct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* cs35l41_private_functions_t::is_mbox_status_correct) (uint32_t cmd, uint32_t status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check HALO MBOX Status against the MBOX Command sent. </p>
<p>Only some states of HALO MBOX Status are valid for each HALO MBOX Command</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>which HALO MBOX Command was most recently sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>what is the HALO MBOX Status read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>true Status is correct/valid</li>
<li>false Status is incorrect/invalid </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a87a23b8eb3c811aba012b87508006b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a23b8eb3c811aba012b87508006b93">&#9670;&nbsp;</a></span>is_mixer_source_used</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* cs35l41_private_functions_t::is_mixer_source_used) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint8_t source)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks all hardware mixer source selections for a specific source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Mixer source to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>true Mixer source 'source' is used</li>
<li>false Mixer source 'source' is not used</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_s35_l41___i_n_p_u_t___s_r_c__.html" title="Settings for MIXER Source Values.">CS35L41_INPUT_SRC_</a> </dd></dl>

</div>
</div>
<a id="aa07eeca75abaca69acc316d0591527a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07eeca75abaca69acc316d0591527a0">&#9670;&nbsp;</a></span>load_control</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::load_control) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load new Control Request to be processed. </p>
<p>Removes next element from Control Request Queue and initializes the corresponding state machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if ID for new Control Request is not valid</li>
<li>CS35L41_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa11935704b9da56c6e6fc2e79858ac41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11935704b9da56c6e6fc2e79858ac41">&#9670;&nbsp;</a></span>power_down_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::power_down_sm) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power Down State Machine. </p>
<p>This state machine performs all necessary steps to transition the CS35L41 to be in Standby power mode. Completing the state machine results in the driver transition to STANDBY or DSP_STANDBY state. The state machine design is documented in the Power Down State Diagram found in the Driver Tech Note.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS35L41_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Power Down State Diagram </dd></dl>

</div>
</div>
<a id="ad5d36b513f6e33a55fa8806cd85f7e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d36b513f6e33a55fa8806cd85f7e17">&#9670;&nbsp;</a></span>power_up_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::power_up_sm) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power Up State Machine. </p>
<p>This state machine performs all necessary steps to transition the CS35L41 to be ready to pass audio through the amplifier DAC. Completing the state machine results in the driver transition to POWER_UP state. The state machine design is documented in the Power Up State Diagram found in the Driver Tech Note.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS35L41_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Power Up State Diagram </dd></dl>

</div>
</div>
<a id="ae6ae1e868279c613f34736c20a45d4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ae1e868279c613f34736c20a45d4f5">&#9670;&nbsp;</a></span>read_reg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::read_reg) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t addr, uint32_t *val, bool is_blocking)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the contents of a single register/memory address. </p>
<p>The main purpose is to handle buffering and BSP calls required for reading a single memory address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>32-bit address to be read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">val</td><td>Pointer to register value read (only used for non-blocking calls) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_blocking</td><td>Indicates whether request is for blocking (true) or non-blocking (false) call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if the call to BSP failed</li>
<li>CS35L41_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Contains platform-dependent code. </dd></dl>

</div>
</div>
<a id="a515d10603ab119e901e6f821c726363e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515d10603ab119e901e6f821c726363e">&#9670;&nbsp;</a></span>reset_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::reset_sm) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset State Machine. </p>
<p>This state machine performs all necessary steps to reset the CS35L41 and put it into STANDBY state. The state machine design is documented in the Reset State Diagram found in the Driver Tech Note.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS35L41_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Reset State Diagram </dd></dl>

</div>
</div>
<a id="ae7ab34f9a1b2f9e40a0ebca901f54e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ab34f9a1b2f9e40a0ebca901f54e20">&#9670;&nbsp;</a></span>timer_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* cs35l41_private_functions_t::timer_callback) (uint32_t status, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the driver when the BSP Timer expires. </p>
<p>This callback is given as a parameter for all non-blocking calls to the set_timer() API in <a class="el" href="structbsp__driver__if__t.html" title="BSP-to-Driver public API.">bsp_driver_if_t</a>. Currently, the timer is only used for state machines handling Control Requests, so the only action required is to set the CS35L41_FLAGS_TIMEOUT for the state machine being currently processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Status of the asynchronous call to set_timer() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>A pointer to callback argument registered for set_timer(). For the driver, this arg is used for a pointer to the driver state <a class="el" href="structcs35l41__t.html" title="Driver state data structure.">cs35l41_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structbsp__driver__if__t.html" title="BSP-to-Driver public API.">bsp_driver_if_t</a> member set_timer. </dd>
<dd>
<a class="el" href="bsp__driver__if_8h.html#a9da53d6fb2687f1afc4fe77a6d1a101f" title="Callback type for BSP-to-Driver callbacks.">bsp_callback_t</a> </dd></dl>

</div>
</div>
<a id="a3a9fe55eb9babd92801872db7df24b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9fe55eb9babd92801872db7df24b8f">&#9670;&nbsp;</a></span>validate_boot_config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::validate_boot_config) (<a class="el" href="structcs35l41__boot__config__t.html">cs35l41_boot_config_t</a> *config, bool is_fw_boot, bool is_coeff_boot)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the boot configuration provided by the BSP. </p>
<p>According to 'is_fw_boot' and 'is_coeff_boot' flags, checks that all required pointers to boot/coeff images are not NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>pointer to boot configuration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_fw_boot</td><td>whether current action is booting FW; (true) is a FW boot action, (false) is NOT a FW boot action </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_coeff_boot</td><td>whether current action is booting COEFF; (true) is a COEFF boot action, (false) is NOT a COEFF boot action</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if 'config' is NULL, if any required block pointers are NULL</li>
<li>CS35L41_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4410e22074eeece6f37c48f8369067dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4410e22074eeece6f37c48f8369067dd">&#9670;&nbsp;</a></span>write_reg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_private_functions_t::write_reg) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t addr, uint32_t val, bool is_blocking)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the contents of a single register/memory address. </p>
<p>The main purpose is to handle buffering and BSP calls required for writing a single memory address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>32-bit address to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>32-bit value to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_blocking</td><td>Indicates whether request is for blocking (true) or non-blocking (false) call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if the call to BSP failed</li>
<li>CS35L41_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Contains platform-dependent code. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="cs35l41_8h_source.html">cs35l41.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
