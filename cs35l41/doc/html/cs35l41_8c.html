<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: cs35l41.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cs35l41.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The CS35L41 Driver module.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &quot;<a class="el" href="cs35l41_8h_source.html">cs35l41.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="bsp__driver__if_8h_source.html">bsp_driver_if.h</a>&quot;</code><br />
<code>#include &quot;string.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3f66fda6a6dcf7e64c1637d0460e01ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a3f66fda6a6dcf7e64c1637d0460e01ed">CS35L41_INT1_MASK_DEFAULT</a></td></tr>
<tr class="memdesc:a3f66fda6a6dcf7e64c1637d0460e01ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Interrupt Mask for IRQ1_MASK_1 register.  <a href="cs35l41_8c.html#a3f66fda6a6dcf7e64c1637d0460e01ed">More...</a><br /></td></tr>
<tr class="separator:a3f66fda6a6dcf7e64c1637d0460e01ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22eea7b86cb1556e2a2f014c9ead3635"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a22eea7b86cb1556e2a2f014c9ead3635">CS35L41_INT1_SPEAKER_SAFE_MODE_IRQ_MASK</a></td></tr>
<tr class="memdesc:a22eea7b86cb1556e2a2f014c9ead3635"><td class="mdescLeft">&#160;</td><td class="mdescRight">IRQ1 Status Bits for Speaker Safe Mode.  <a href="cs35l41_8c.html#a22eea7b86cb1556e2a2f014c9ead3635">More...</a><br /></td></tr>
<tr class="separator:a22eea7b86cb1556e2a2f014c9ead3635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ab7f942575996c39b38b16060e7c78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a36ab7f942575996c39b38b16060e7c78">CS35L41_INT1_BOOST_IRQ_MASK</a></td></tr>
<tr class="memdesc:a36ab7f942575996c39b38b16060e7c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">IRQ1 Status Bits for Speaker Safe Mode Boost-related Events.  <a href="cs35l41_8c.html#a36ab7f942575996c39b38b16060e7c78">More...</a><br /></td></tr>
<tr class="separator:a36ab7f942575996c39b38b16060e7c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21fc219b2153fb4f1c0b59b1883c9fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#aa21fc219b2153fb4f1c0b59b1883c9fb">CS35L41_ERR_RLS_SPEAKER_SAFE_MODE_MASK</a></td></tr>
<tr class="memdesc:aa21fc219b2153fb4f1c0b59b1883c9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle Mask for MSM_ERROR_RELEASE_REG to Release from Speaker Safe Mode.  <a href="cs35l41_8c.html#aa21fc219b2153fb4f1c0b59b1883c9fb">More...</a><br /></td></tr>
<tr class="separator:aa21fc219b2153fb4f1c0b59b1883c9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b83fcc823606b6710b9189848538df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a13b83fcc823606b6710b9189848538df">CS35L41_FS_MON0_BETA</a></td></tr>
<tr class="memdesc:a13b83fcc823606b6710b9189848538df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beta value used to calculate value for CCM_FS_MON_0_REG.  <a href="cs35l41_8c.html#a13b83fcc823606b6710b9189848538df">More...</a><br /></td></tr>
<tr class="separator:a13b83fcc823606b6710b9189848538df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87beb66bb0c473abeb71956e98049b1f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a87beb66bb0c473abeb71956e98049b1f">CS35L41_CAL_STATUS_CALIB_SUCCESS</a></td></tr>
<tr class="memdesc:a87beb66bb0c473abeb71956e98049b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of CS35L41_CAL_STATUS that indicates Calibration success.  <a href="cs35l41_8c.html#a87beb66bb0c473abeb71956e98049b1f">More...</a><br /></td></tr>
<tr class="separator:a87beb66bb0c473abeb71956e98049b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6ea08f53482b68111bc6818b11d3e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#aab6ea08f53482b68111bc6818b11d3e8">CS35L41_SYNC_CTRLS_TOTAL</a></td></tr>
<tr class="memdesc:aab6ea08f53482b68111bc6818b11d3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of HALO FW controls to cache before CS35L41 Power Up.  <a href="cs35l41_8c.html#aab6ea08f53482b68111bc6818b11d3e8">More...</a><br /></td></tr>
<tr class="separator:aab6ea08f53482b68111bc6818b11d3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a89ece368dc6278dae648c3d8378e2486"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a89ece368dc6278dae648c3d8378e2486">cs35l41_timer_callback</a> (uint32_t status, void *cb_arg)</td></tr>
<tr class="memdesc:a89ece368dc6278dae648c3d8378e2486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the driver when the BSP Timer expires.  <a href="cs35l41_8c.html#a89ece368dc6278dae648c3d8378e2486">More...</a><br /></td></tr>
<tr class="separator:a89ece368dc6278dae648c3d8378e2486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd032d344f67fffe64e55a79698d9771"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#afd032d344f67fffe64e55a79698d9771">cs35l41_cp_read_callback</a> (uint32_t status, void *cb_arg)</td></tr>
<tr class="memdesc:afd032d344f67fffe64e55a79698d9771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the driver when the BSP Control Port (cp) read transaction completes.  <a href="cs35l41_8c.html#afd032d344f67fffe64e55a79698d9771">More...</a><br /></td></tr>
<tr class="separator:afd032d344f67fffe64e55a79698d9771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade122eb53e44fea974c18b194a6212e7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#ade122eb53e44fea974c18b194a6212e7">cs35l41_cp_write_callback</a> (uint32_t status, void *cb_arg)</td></tr>
<tr class="memdesc:ade122eb53e44fea974c18b194a6212e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the driver when the BSP Control Port (cp) write transaction completes.  <a href="cs35l41_8c.html#ade122eb53e44fea974c18b194a6212e7">More...</a><br /></td></tr>
<tr class="separator:ade122eb53e44fea974c18b194a6212e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e6cf7260fb4f9029a46a869da5459c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a52e6cf7260fb4f9029a46a869da5459c">cs35l41_irq_callback</a> (uint32_t status, void *cb_arg)</td></tr>
<tr class="memdesc:a52e6cf7260fb4f9029a46a869da5459c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the driver when the CS35L41 INTb GPIO drops low.  <a href="cs35l41_8c.html#a52e6cf7260fb4f9029a46a869da5459c">More...</a><br /></td></tr>
<tr class="separator:a52e6cf7260fb4f9029a46a869da5459c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac930902102dc12afb7363844e579101f"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#ac930902102dc12afb7363844e579101f">cs35l41_read_reg</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t addr, uint32_t *val, bool is_blocking)</td></tr>
<tr class="memdesc:ac930902102dc12afb7363844e579101f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the contents of a single register/memory address.  <a href="cs35l41_8c.html#ac930902102dc12afb7363844e579101f">More...</a><br /></td></tr>
<tr class="separator:ac930902102dc12afb7363844e579101f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528751401192802a847b1732b6f8a416"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a528751401192802a847b1732b6f8a416">cs35l41_write_reg</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t addr, uint32_t val, bool is_blocking)</td></tr>
<tr class="memdesc:a528751401192802a847b1732b6f8a416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the contents of a single register/memory address.  <a href="cs35l41_8c.html#a528751401192802a847b1732b6f8a416">More...</a><br /></td></tr>
<tr class="separator:a528751401192802a847b1732b6f8a416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1e8a4a7cc9f91a0a380da67d9d5a48"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#aea1e8a4a7cc9f91a0a380da67d9d5a48">cs35l41_reset_sm</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:aea1e8a4a7cc9f91a0a380da67d9d5a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset State Machine.  <a href="cs35l41_8c.html#aea1e8a4a7cc9f91a0a380da67d9d5a48">More...</a><br /></td></tr>
<tr class="separator:aea1e8a4a7cc9f91a0a380da67d9d5a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a40bbc72ea6f7d9779cf56313e349a3"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a4a40bbc72ea6f7d9779cf56313e349a3">cs35l41_boot_sm</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a4a40bbc72ea6f7d9779cf56313e349a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot State Machine.  <a href="cs35l41_8c.html#a4a40bbc72ea6f7d9779cf56313e349a3">More...</a><br /></td></tr>
<tr class="separator:a4a40bbc72ea6f7d9779cf56313e349a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379e8b7396443d1f2a20711f6da4c8f9"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a379e8b7396443d1f2a20711f6da4c8f9">cs35l41_power_up_sm</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a379e8b7396443d1f2a20711f6da4c8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power Up State Machine.  <a href="cs35l41_8c.html#a379e8b7396443d1f2a20711f6da4c8f9">More...</a><br /></td></tr>
<tr class="separator:a379e8b7396443d1f2a20711f6da4c8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3844fee380afa9456ecbf8bb33759051"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a3844fee380afa9456ecbf8bb33759051">cs35l41_power_down_sm</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a3844fee380afa9456ecbf8bb33759051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power Down State Machine.  <a href="cs35l41_8c.html#a3844fee380afa9456ecbf8bb33759051">More...</a><br /></td></tr>
<tr class="separator:a3844fee380afa9456ecbf8bb33759051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e07b7824c082a5a2e2d7b856244a915"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a4e07b7824c082a5a2e2d7b856244a915">cs35l41_configure_sm</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a4e07b7824c082a5a2e2d7b856244a915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure State Machine.  <a href="cs35l41_8c.html#a4e07b7824c082a5a2e2d7b856244a915">More...</a><br /></td></tr>
<tr class="separator:a4e07b7824c082a5a2e2d7b856244a915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6486e2ae0b69ee0d236ee2ac07f45a86"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a6486e2ae0b69ee0d236ee2ac07f45a86">cs35l41_field_access_sm</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a6486e2ae0b69ee0d236ee2ac07f45a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Field Access State Machine.  <a href="cs35l41_8c.html#a6486e2ae0b69ee0d236ee2ac07f45a86">More...</a><br /></td></tr>
<tr class="separator:a6486e2ae0b69ee0d236ee2ac07f45a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f77829c590c26625917b767def2f24d"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a1f77829c590c26625917b767def2f24d">cs35l41_calibration_sm</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a1f77829c590c26625917b767def2f24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibration State Machine.  <a href="cs35l41_8c.html#a1f77829c590c26625917b767def2f24d">More...</a><br /></td></tr>
<tr class="separator:a1f77829c590c26625917b767def2f24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fea52aa10c61908d49fe2867d0e6ab"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#aa3fea52aa10c61908d49fe2867d0e6ab">cs35l41_get_dsp_status_sm</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:aa3fea52aa10c61908d49fe2867d0e6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DSP Status State Machine.  <a href="cs35l41_8c.html#aa3fea52aa10c61908d49fe2867d0e6ab">More...</a><br /></td></tr>
<tr class="separator:aa3fea52aa10c61908d49fe2867d0e6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea3b5c90e2ff2d2089caa9bc8bdeeca"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#afea3b5c90e2ff2d2089caa9bc8bdeeca">cs35l41_event_sm</a> (void *driver)</td></tr>
<tr class="memdesc:afea3b5c90e2ff2d2089caa9bc8bdeeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event Handler State Machine.  <a href="cs35l41_8c.html#afea3b5c90e2ff2d2089caa9bc8bdeeca">More...</a><br /></td></tr>
<tr class="separator:afea3b5c90e2ff2d2089caa9bc8bdeeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5445bd2cf22c4e59374d41573ca32574"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a5445bd2cf22c4e59374d41573ca32574">cs35l41_get_errata</a> (uint32_t devid, uint32_t revid, const uint32_t **errata)</td></tr>
<tr class="memdesc:a5445bd2cf22c4e59374d41573ca32574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointer to correct errata based on DEVID/REVID.  <a href="cs35l41_8c.html#a5445bd2cf22c4e59374d41573ca32574">More...</a><br /></td></tr>
<tr class="separator:a5445bd2cf22c4e59374d41573ca32574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb027e711b6d0117c21a917f222a8ae6"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#adb027e711b6d0117c21a917f222a8ae6">cs35l41_cp_bulk_read</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t addr, uint32_t length)</td></tr>
<tr class="memdesc:adb027e711b6d0117c21a917f222a8ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads contents from a consecutive number of memory addresses.  <a href="cs35l41_8c.html#adb027e711b6d0117c21a917f222a8ae6">More...</a><br /></td></tr>
<tr class="separator:adb027e711b6d0117c21a917f222a8ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14039264782b7e5f2fa52f82b8a667ae"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a14039264782b7e5f2fa52f82b8a667ae">cs35l41_apply_trim_word</a> (uint8_t *otp_mem, uint32_t bit_count, uint32_t *reg_val, uint32_t shift, uint32_t size)</td></tr>
<tr class="memdesc:a14039264782b7e5f2fa52f82b8a667ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies OTP trim bit-field to current register word value.  <a href="cs35l41_8c.html#a14039264782b7e5f2fa52f82b8a667ae">More...</a><br /></td></tr>
<tr class="separator:a14039264782b7e5f2fa52f82b8a667ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ad67fea109bf2f3140f193c854d17f"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#ae5ad67fea109bf2f3140f193c854d17f">cs35l41_validate_boot_config</a> (<a class="el" href="structcs35l41__boot__config__t.html">cs35l41_boot_config_t</a> *config, bool is_fw_boot, bool is_coeff_boot)</td></tr>
<tr class="memdesc:ae5ad67fea109bf2f3140f193c854d17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the boot configuration provided by the BSP.  <a href="cs35l41_8c.html#ae5ad67fea109bf2f3140f193c854d17f">More...</a><br /></td></tr>
<tr class="separator:ae5ad67fea109bf2f3140f193c854d17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd25ed2a9f5db25c1fc54812efe135e"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a5cd25ed2a9f5db25c1fc54812efe135e">cs35l41_cp_bulk_write</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t addr, uint8_t *bytes, uint32_t length)</td></tr>
<tr class="memdesc:a5cd25ed2a9f5db25c1fc54812efe135e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes from byte array to consecutive number of Control Port memory addresses.  <a href="cs35l41_8c.html#a5cd25ed2a9f5db25c1fc54812efe135e">More...</a><br /></td></tr>
<tr class="separator:a5cd25ed2a9f5db25c1fc54812efe135e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34225c39fb480eb098b00ab4db08179f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a34225c39fb480eb098b00ab4db08179f">cs35l41_control_q_copy</a> (void *from, void *to)</td></tr>
<tr class="memdesc:a34225c39fb480eb098b00ab4db08179f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements 'copy' method for Control Request Queue contents.  <a href="cs35l41_8c.html#a34225c39fb480eb098b00ab4db08179f">More...</a><br /></td></tr>
<tr class="separator:a34225c39fb480eb098b00ab4db08179f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f698d5cc802ae1a0aaa35ef2bcb371f"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a6f698d5cc802ae1a0aaa35ef2bcb371f">cs35l41_is_control_valid</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a6f698d5cc802ae1a0aaa35ef2bcb371f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the currently processed Control Request is valid for the current state of the driver.  <a href="cs35l41_8c.html#a6f698d5cc802ae1a0aaa35ef2bcb371f">More...</a><br /></td></tr>
<tr class="separator:a6f698d5cc802ae1a0aaa35ef2bcb371f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93893a759db17a077e6acfd433658b40"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a93893a759db17a077e6acfd433658b40">cs35l41_load_control</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a93893a759db17a077e6acfd433658b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load new Control Request to be processed.  <a href="cs35l41_8c.html#a93893a759db17a077e6acfd433658b40">More...</a><br /></td></tr>
<tr class="separator:a93893a759db17a077e6acfd433658b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fbfdfa7902ffc35708f14d6658d32f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a24fbfdfa7902ffc35708f14d6658d32f">cs35l41_is_mbox_status_correct</a> (uint32_t cmd, uint32_t status)</td></tr>
<tr class="memdesc:a24fbfdfa7902ffc35708f14d6658d32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check HALO MBOX Status against the MBOX Command sent.  <a href="cs35l41_8c.html#a24fbfdfa7902ffc35708f14d6658d32f">More...</a><br /></td></tr>
<tr class="separator:a24fbfdfa7902ffc35708f14d6658d32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f68b4f63b412f6e9bfec7c42d75d24"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a88f68b4f63b412f6e9bfec7c42d75d24">cs35l41_irq_to_event_id</a> (uint32_t *<a class="el" href="cs35l41_8c.html#a93ed7ca914fe1948b5d02bdf1b1c0083">irq_statuses</a>)</td></tr>
<tr class="memdesc:a88f68b4f63b412f6e9bfec7c42d75d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps IRQ Flag to Event ID passed to BSP.  <a href="cs35l41_8c.html#a88f68b4f63b412f6e9bfec7c42d75d24">More...</a><br /></td></tr>
<tr class="separator:a88f68b4f63b412f6e9bfec7c42d75d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0b0b678346b30ba3f1d06bddf4c52a"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a4d0b0b678346b30ba3f1d06bddf4c52a">cs35l41_apply_configs</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a4d0b0b678346b30ba3f1d06bddf4c52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply all driver one-time configurations to corresponding Control Port register/memory addresses.  <a href="cs35l41_8c.html#a4d0b0b678346b30ba3f1d06bddf4c52a">More...</a><br /></td></tr>
<tr class="separator:a4d0b0b678346b30ba3f1d06bddf4c52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b78e24a8f4cdf5d4979a96a3f896ee"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a78b78e24a8f4cdf5d4979a96a3f896ee">cs35l41_is_mixer_source_used</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint8_t source)</td></tr>
<tr class="memdesc:a78b78e24a8f4cdf5d4979a96a3f896ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks all hardware mixer source selections for a specific source.  <a href="cs35l41_8c.html#a78b78e24a8f4cdf5d4979a96a3f896ee">More...</a><br /></td></tr>
<tr class="separator:a78b78e24a8f4cdf5d4979a96a3f896ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db514b0ca993a10980292508e04d76d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a8db514b0ca993a10980292508e04d76d">cs35l41_initialize</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a8db514b0ca993a10980292508e04d76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize driver state/handle.  <a href="cs35l41_8c.html#a8db514b0ca993a10980292508e04d76d">More...</a><br /></td></tr>
<tr class="separator:a8db514b0ca993a10980292508e04d76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60ae5bcbfc33b01d7303b34adeac1b1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#aa60ae5bcbfc33b01d7303b34adeac1b1">cs35l41_configure</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, <a class="el" href="structcs35l41__config__t.html">cs35l41_config_t</a> *config)</td></tr>
<tr class="memdesc:aa60ae5bcbfc33b01d7303b34adeac1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures driver state/handle.  <a href="cs35l41_8c.html#aa60ae5bcbfc33b01d7303b34adeac1b1">More...</a><br /></td></tr>
<tr class="separator:aa60ae5bcbfc33b01d7303b34adeac1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9035b122e866a3ee7ae60c00fd1cebb1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a9035b122e866a3ee7ae60c00fd1cebb1">cs35l41_process</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a9035b122e866a3ee7ae60c00fd1cebb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes driver state machines.  <a href="cs35l41_8c.html#a9035b122e866a3ee7ae60c00fd1cebb1">More...</a><br /></td></tr>
<tr class="separator:a9035b122e866a3ee7ae60c00fd1cebb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e81c877116c2c758dcb125e60d5515"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#ac5e81c877116c2c758dcb125e60d5515">cs35l41_control</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, <a class="el" href="structcs35l41__control__request__t.html">cs35l41_control_request_t</a> req)</td></tr>
<tr class="memdesc:ac5e81c877116c2c758dcb125e60d5515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a Control Request to the driver.  <a href="cs35l41_8c.html#ac5e81c877116c2c758dcb125e60d5515">More...</a><br /></td></tr>
<tr class="separator:ac5e81c877116c2c758dcb125e60d5515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3c6661e89981f955f286028c8aad95"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#add3c6661e89981f955f286028c8aad95">cs35l41_boot</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, <a class="el" href="cs35l41_8h.html#a53bbdd9f24b4b7d8bd4fd33c3053ad8d">cs35l41_control_callback_t</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:add3c6661e89981f955f286028c8aad95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot the CS35L41.  <a href="cs35l41_8c.html#add3c6661e89981f955f286028c8aad95">More...</a><br /></td></tr>
<tr class="separator:add3c6661e89981f955f286028c8aad95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a149fe6daddf8abffbc085665df3ef"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a83a149fe6daddf8abffbc085665df3ef">cs35l41_power</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t power_state, <a class="el" href="cs35l41_8h.html#a53bbdd9f24b4b7d8bd4fd33c3053ad8d">cs35l41_control_callback_t</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a83a149fe6daddf8abffbc085665df3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the power state.  <a href="cs35l41_8c.html#a83a149fe6daddf8abffbc085665df3ef">More...</a><br /></td></tr>
<tr class="separator:a83a149fe6daddf8abffbc085665df3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc65dcc5abdd58113ff77470717cdaa"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a6cc65dcc5abdd58113ff77470717cdaa">cs35l41_calibrate</a> (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t ambient_temp_deg_c, <a class="el" href="cs35l41_8h.html#a53bbdd9f24b4b7d8bd4fd33c3053ad8d">cs35l41_control_callback_t</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a6cc65dcc5abdd58113ff77470717cdaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrate the HALO DSP Protection Algorithm.  <a href="cs35l41_8c.html#a6cc65dcc5abdd58113ff77470717cdaa">More...</a><br /></td></tr>
<tr class="separator:a6cc65dcc5abdd58113ff77470717cdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:acbb00b021aae35d40c35832963ec95a3"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#acbb00b021aae35d40c35832963ec95a3">cs35l41_revb0_errata_patch</a> []</td></tr>
<tr class="memdesc:acbb00b021aae35d40c35832963ec95a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CS35L41 RevB0 Register Patch Errata.  <a href="cs35l41_8c.html#acbb00b021aae35d40c35832963ec95a3">More...</a><br /></td></tr>
<tr class="separator:acbb00b021aae35d40c35832963ec95a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b5e16399942433e00eb52bc96e21fb"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structcs35l41__otp__packed__entry__t.html">cs35l41_otp_packed_entry_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a76b5e16399942433e00eb52bc96e21fb">otp_map_1</a> []</td></tr>
<tr class="memdesc:a76b5e16399942433e00eb52bc96e21fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">CS35L41 RevB2 OTP Map 1.  <a href="cs35l41_8c.html#a76b5e16399942433e00eb52bc96e21fb">More...</a><br /></td></tr>
<tr class="separator:a76b5e16399942433e00eb52bc96e21fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd16ca37a9ad9072b9a8a81730ccc474"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structcs35l41__otp__map__t.html">cs35l41_otp_map_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#acd16ca37a9ad9072b9a8a81730ccc474">cs35l41_otp_maps</a> []</td></tr>
<tr class="memdesc:acd16ca37a9ad9072b9a8a81730ccc474"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of possible OTP Maps for CS35L41 RevB2.  <a href="cs35l41_8c.html#acd16ca37a9ad9072b9a8a81730ccc474">More...</a><br /></td></tr>
<tr class="separator:acd16ca37a9ad9072b9a8a81730ccc474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9efec6548c3cd9d46d2e7763b977fde"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#ac9efec6548c3cd9d46d2e7763b977fde">cs35l41_post_boot_config</a> []</td></tr>
<tr class="memdesc:ac9efec6548c3cd9d46d2e7763b977fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register configuration after HALO FW is loaded in Boot SM.  <a href="cs35l41_8c.html#ac9efec6548c3cd9d46d2e7763b977fde">More...</a><br /></td></tr>
<tr class="separator:ac9efec6548c3cd9d46d2e7763b977fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f26adf842c5693aefc7672e8fae2377"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a2f26adf842c5693aefc7672e8fae2377">cs35l41_pup_patch</a> []</td></tr>
<tr class="memdesc:a2f26adf842c5693aefc7672e8fae2377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register configuration to send just before the CS35L41 is powered up in Power Up SM.  <a href="cs35l41_8c.html#a2f26adf842c5693aefc7672e8fae2377">More...</a><br /></td></tr>
<tr class="separator:a2f26adf842c5693aefc7672e8fae2377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fc0210792d264448d59ec3c159096f"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a80fc0210792d264448d59ec3c159096f">cs35l41_pdn_patch</a> []</td></tr>
<tr class="memdesc:a80fc0210792d264448d59ec3c159096f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register configuration to send just after the CS35L41 is powered down in Power Down SM.  <a href="cs35l41_8c.html#a80fc0210792d264448d59ec3c159096f">More...</a><br /></td></tr>
<tr class="separator:a80fc0210792d264448d59ec3c159096f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aefb95b3e8696f351533db309f01d08"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a7aefb95b3e8696f351533db309f01d08">cs35l41_mem_lock</a> []</td></tr>
<tr class="memdesc:a7aefb95b3e8696f351533db309f01d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register configuration to lock HALO memory regions.  <a href="cs35l41_8c.html#a7aefb95b3e8696f351533db309f01d08">More...</a><br /></td></tr>
<tr class="separator:a7aefb95b3e8696f351533db309f01d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22054eab374b92a276f11d258b6585e"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#ab22054eab374b92a276f11d258b6585e">cs35l41_frame_sync_regs</a> []</td></tr>
<tr class="memdesc:ab22054eab374b92a276f11d258b6585e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register addresses to set all HALO sample rates to the same value.  <a href="cs35l41_8c.html#ab22054eab374b92a276f11d258b6585e">More...</a><br /></td></tr>
<tr class="separator:ab22054eab374b92a276f11d258b6585e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e0f5f19a78b98e8006663b9f0148f0"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a01e0f5f19a78b98e8006663b9f0148f0">cs35l41_config_register_addresses</a> [<a class="el" href="cs35l41_8h.html#aca640e23d80e448d463d234b5624922e">CS35L41_CONFIG_REGISTERS_TOTAL</a>]</td></tr>
<tr class="memdesc:a01e0f5f19a78b98e8006663b9f0148f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register addresses to modify during Configure SM.  <a href="cs35l41_8c.html#a01e0f5f19a78b98e8006663b9f0148f0">More...</a><br /></td></tr>
<tr class="separator:a01e0f5f19a78b98e8006663b9f0148f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852e72d23608767f4636edfc4d2ee852"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a852e72d23608767f4636edfc4d2ee852">cs35l41_dsp_status_addresses</a> [<a class="el" href="cs35l41_8h.html#a1196a694803be40d4177f6fec416195d">CS35L41_DSP_STATUS_WORDS_TOTAL</a>]</td></tr>
<tr class="memdesc:a852e72d23608767f4636edfc4d2ee852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register/DSP Memory addresses to read during Get DSP Status SM.  <a href="cs35l41_8c.html#a852e72d23608767f4636edfc4d2ee852">More...</a><br /></td></tr>
<tr class="separator:a852e72d23608767f4636edfc4d2ee852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ed7ca914fe1948b5d02bdf1b1c0083"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a93ed7ca914fe1948b5d02bdf1b1c0083">irq_statuses</a> [4]</td></tr>
<tr class="memdesc:a93ed7ca914fe1948b5d02bdf1b1c0083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache for contents of IRQ1_EINT_*_REG interrupt flag registers.  <a href="cs35l41_8c.html#a93ed7ca914fe1948b5d02bdf1b1c0083">More...</a><br /></td></tr>
<tr class="separator:a93ed7ca914fe1948b5d02bdf1b1c0083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac503fe04b98cb8063ca6a6d184d0b2c3"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#ac503fe04b98cb8063ca6a6d184d0b2c3">irq_masks</a> [4]</td></tr>
<tr class="memdesc:ac503fe04b98cb8063ca6a6d184d0b2c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache for contents of IRQ1_MASK_*_REG interrupt mask registers.  <a href="cs35l41_8c.html#ac503fe04b98cb8063ca6a6d184d0b2c3">More...</a><br /></td></tr>
<tr class="separator:ac503fe04b98cb8063ca6a6d184d0b2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c87f06e30be9e9a0313fd8aab43344"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structcs35l41__private__functions__t.html">cs35l41_private_functions_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a41c87f06e30be9e9a0313fd8aab43344">cs35l41_private_functions_s</a></td></tr>
<tr class="memdesc:a41c87f06e30be9e9a0313fd8aab43344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer table for Private API implementation.  <a href="cs35l41_8c.html#a41c87f06e30be9e9a0313fd8aab43344">More...</a><br /></td></tr>
<tr class="separator:a41c87f06e30be9e9a0313fd8aab43344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ef8fd9fc6d900ceff250911bb90039"><td class="memItemLeft" align="right" valign="top"><a id="a31ef8fd9fc6d900ceff250911bb90039"></a>
<a class="el" href="structcs35l41__private__functions__t.html">cs35l41_private_functions_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a31ef8fd9fc6d900ceff250911bb90039">cs35l41_private_functions_g</a></td></tr>
<tr class="memdesc:a31ef8fd9fc6d900ceff250911bb90039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Private API implementation. <br /></td></tr>
<tr class="separator:a31ef8fd9fc6d900ceff250911bb90039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dda85fac851b50d63353e1868fec98"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structcs35l41__functions__t.html">cs35l41_functions_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#ac8dda85fac851b50d63353e1868fec98">cs35l41_functions_s</a></td></tr>
<tr class="memdesc:ac8dda85fac851b50d63353e1868fec98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer table for Public API implementation.  <a href="cs35l41_8c.html#ac8dda85fac851b50d63353e1868fec98">More...</a><br /></td></tr>
<tr class="separator:ac8dda85fac851b50d63353e1868fec98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c64a2c9d9a485d9b66fd537aa32ec83"><td class="memItemLeft" align="right" valign="top"><a id="a7c64a2c9d9a485d9b66fd537aa32ec83"></a>
<a class="el" href="structcs35l41__functions__t.html">cs35l41_functions_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cs35l41_8c.html#a7c64a2c9d9a485d9b66fd537aa32ec83">cs35l41_functions_g</a></td></tr>
<tr class="memdesc:a7c64a2c9d9a485d9b66fd537aa32ec83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Public API implementation. <br /></td></tr>
<tr class="separator:a7c64a2c9d9a485d9b66fd537aa32ec83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The CS35L41 Driver module. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) Cirrus Logic 2019 All Rights Reserved, <a href="http://www.cirrus.com/">http://www.cirrus.com/</a></dd></dl>
<p>This code and information are provided 'as-is' without warranty of any kind, either expressed or implied, including but not limited to the implied warranties of merchantability and/or fitness for a particular purpose. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a87beb66bb0c473abeb71956e98049b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87beb66bb0c473abeb71956e98049b1f">&#9670;&nbsp;</a></span>CS35L41_CAL_STATUS_CALIB_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CS35L41_CAL_STATUS_CALIB_SUCCESS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value of CS35L41_CAL_STATUS that indicates Calibration success. </p>
<dl class="section see"><dt>See also</dt><dd>CS35L41_CAL_STATUS </dd></dl>

</div>
</div>
<a id="aa21fc219b2153fb4f1c0b59b1883c9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21fc219b2153fb4f1c0b59b1883c9fb">&#9670;&nbsp;</a></span>CS35L41_ERR_RLS_SPEAKER_SAFE_MODE_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CS35L41_ERR_RLS_SPEAKER_SAFE_MODE_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggle Mask for MSM_ERROR_RELEASE_REG to Release from Speaker Safe Mode. </p>
<p>The relevant fields in MSM_ERROR_RELEASE_REG that require release sequence are:</p><ul>
<li>b6 - TEMP_ERR</li>
<li>b5 - TEMP_WARN</li>
<li>b4 - BST_UVP</li>
<li>b3 - BST_OVP</li>
<li>b2 - BST_SHORT</li>
<li>b1 - AMP_SHORT</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_e_c_t_i_o_n__7__5___m_s_m.html#gacd0b1f4cee9ecad48d2a9786c4d66bb0">MSM_ERROR_RELEASE_REG</a> </dd>
<dd>
Datasheet Section 4.16.1.1 </dd></dl>

</div>
</div>
<a id="a13b83fcc823606b6710b9189848538df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b83fcc823606b6710b9189848538df">&#9670;&nbsp;</a></span>CS35L41_FS_MON0_BETA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CS35L41_FS_MON0_BETA</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Beta value used to calculate value for CCM_FS_MON_0_REG. </p>
<dl class="section see"><dt>See also</dt><dd>Datasheet Section 4.13.9 </dd></dl>

</div>
</div>
<a id="a36ab7f942575996c39b38b16060e7c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ab7f942575996c39b38b16060e7c78">&#9670;&nbsp;</a></span>CS35L41_INT1_BOOST_IRQ_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CS35L41_INT1_BOOST_IRQ_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IRQ1 Status Bits for Speaker Safe Mode Boost-related Events. </p>
<p>If any of the bits in the mask below are set in IRQ1_EINT_1, the amplifier will have entered Speaker Safe Mode and will require additional steps to release from Speaker Safe Mode.</p><ul>
<li>b8 - BST_SHORT_ERR_MASK1</li>
<li>b7 - BST_DCM_UVP_ERR_MASK1</li>
<li>b6 - BST_OVP_ERR_MASK1</li>
</ul>
<dl class="section see"><dt>See also</dt><dd>IRQ1_EINT_1 </dd>
<dd>
Datasheet Section 4.16.1.1 </dd></dl>

</div>
</div>
<a id="a3f66fda6a6dcf7e64c1637d0460e01ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f66fda6a6dcf7e64c1637d0460e01ed">&#9670;&nbsp;</a></span>CS35L41_INT1_MASK_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CS35L41_INT1_MASK_DEFAULT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default Interrupt Mask for IRQ1_MASK_1 register. </p>
<p>The interrupts that are unmasked in Interrupt Status and Mask Control (IRQ1) are:</p><ul>
<li>b31 - AMP_ERR_MASK1</li>
<li>b17 - TEMP_ERR_MASK1</li>
<li>b15 - TEMP_WARN_RISE_MASK1</li>
<li>b8 - BST_SHORT_ERR_MASK1</li>
<li>b7 - BST_DCM_UVP_ERR_MASK1</li>
<li>b6 - BST_OVP_ERR_MASK1</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_e_c_t_i_o_n__7__23___i_r_q1.html#gaf3694b5f989ff3a9094c1d7a3f6af2e4">IRQ1_IRQ1_MASK_1_REG</a> </dd></dl>

</div>
</div>
<a id="a22eea7b86cb1556e2a2f014c9ead3635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22eea7b86cb1556e2a2f014c9ead3635">&#9670;&nbsp;</a></span>CS35L41_INT1_SPEAKER_SAFE_MODE_IRQ_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CS35L41_INT1_SPEAKER_SAFE_MODE_IRQ_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IRQ1 Status Bits for Speaker Safe Mode. </p>
<p>If any of the bits in the mask below are set in IRQ1_EINT_1, the amplifier will have entered Speaker Safe Mode.</p><ul>
<li>b31 - AMP_ERR_MASK1</li>
<li>b17 - TEMP_ERR_MASK1</li>
<li>b8 - BST_SHORT_ERR_MASK1</li>
<li>b7 - BST_DCM_UVP_ERR_MASK1</li>
<li>b6 - BST_OVP_ERR_MASK1</li>
</ul>
<dl class="section see"><dt>See also</dt><dd>IRQ1_EINT_1 </dd>
<dd>
Datasheet Section 4.16.1.1 </dd></dl>

</div>
</div>
<a id="aab6ea08f53482b68111bc6818b11d3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6ea08f53482b68111bc6818b11d3e8">&#9670;&nbsp;</a></span>CS35L41_SYNC_CTRLS_TOTAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CS35L41_SYNC_CTRLS_TOTAL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total number of HALO FW controls to cache before CS35L41 Power Up. </p>
<p>Currently, there are no HALO FW controls that are cached in the driver.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cs35l41_8c.html#a379e8b7396443d1f2a20711f6da4c8f9" title="Power Up State Machine.">cs35l41_power_up_sm</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4d0b0b678346b30ba3f1d06bddf4c52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0b0b678346b30ba3f1d06bddf4c52a">&#9670;&nbsp;</a></span>cs35l41_apply_configs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_apply_configs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply all driver one-time configurations to corresponding Control Port register/memory addresses. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#ad70a8fb4d21e55478f1b1bcb2708ef8b" title="Apply all driver one-time configurations to corresponding Control Port register/memory addresses.">cs35l41_private_functions_t.apply_configs</a> </p>

</div>
</div>
<a id="a14039264782b7e5f2fa52f82b8a667ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14039264782b7e5f2fa52f82b8a667ae">&#9670;&nbsp;</a></span>cs35l41_apply_trim_word()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_apply_trim_word </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>otp_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bit_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>reg_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies OTP trim bit-field to current register word value. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#a28ee2745d3513222d4681c7d5009569a" title="Applies OTP trim bit-field to current register word value.">cs35l41_private_functions_t.apply_trim_word</a> </p>

</div>
</div>
<a id="add3c6661e89981f955f286028c8aad95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3c6661e89981f955f286028c8aad95">&#9670;&nbsp;</a></span>cs35l41_boot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cs35l41_boot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cs35l41_8h.html#a53bbdd9f24b4b7d8bd4fd33c3053ad8d">cs35l41_control_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boot the CS35L41. </p>
<p>Implementation of <a class="el" href="structcs35l41__functions__t.html#ac89a3cbb49b0bb687fc201ccace406cc" title="Boot the CS35L41.">cs35l41_functions_t.boot</a> </p>

</div>
</div>
<a id="a4a40bbc72ea6f7d9779cf56313e349a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a40bbc72ea6f7d9779cf56313e349a3">&#9670;&nbsp;</a></span>cs35l41_boot_sm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_boot_sm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boot State Machine. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#ae268af039a2d1efe43d7d02f79a55aef" title="Boot State Machine.">cs35l41_private_functions_t.boot_sm</a> </p>

</div>
</div>
<a id="a6cc65dcc5abdd58113ff77470717cdaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc65dcc5abdd58113ff77470717cdaa">&#9670;&nbsp;</a></span>cs35l41_calibrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cs35l41_calibrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ambient_temp_deg_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cs35l41_8h.html#a53bbdd9f24b4b7d8bd4fd33c3053ad8d">cs35l41_control_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calibrate the HALO DSP Protection Algorithm. </p>
<p>Implementation of <a class="el" href="structcs35l41__functions__t.html#ab8fa0dbd155a06e0f45540b99d00c88d" title="Calibrate the HALO DSP Protection Algorithm.">cs35l41_functions_t.calibrate</a> </p>

</div>
</div>
<a id="a1f77829c590c26625917b767def2f24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f77829c590c26625917b767def2f24d">&#9670;&nbsp;</a></span>cs35l41_calibration_sm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_calibration_sm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calibration State Machine. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#a7a64f0be724b6bfc6231d9086db14035" title="Calibration State Machine.">cs35l41_private_functions_t.calibration_sm</a> </p>

</div>
</div>
<a id="aa60ae5bcbfc33b01d7303b34adeac1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60ae5bcbfc33b01d7303b34adeac1b1">&#9670;&nbsp;</a></span>cs35l41_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cs35l41_configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcs35l41__config__t.html">cs35l41_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures driver state/handle. </p>
<p>Implementation of <a class="el" href="structcs35l41__functions__t.html#a9806ed5b318b282c83bf93c994ba2a43" title="Configures driver state/handle.">cs35l41_functions_t.configure</a> </p>

</div>
</div>
<a id="a4e07b7824c082a5a2e2d7b856244a915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e07b7824c082a5a2e2d7b856244a915">&#9670;&nbsp;</a></span>cs35l41_configure_sm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_configure_sm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure State Machine. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#a7deba30ac02db83cb86450d42b7afb02" title="Configure State Machine.">cs35l41_private_functions_t.configure_sm</a> </p>

</div>
</div>
<a id="ac5e81c877116c2c758dcb125e60d5515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e81c877116c2c758dcb125e60d5515">&#9670;&nbsp;</a></span>cs35l41_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cs35l41_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcs35l41__control__request__t.html">cs35l41_control_request_t</a>&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a Control Request to the driver. </p>
<p>Implementation of <a class="el" href="structcs35l41__functions__t.html#a27ef4444485f6f7f0151987dec3b62da" title="Submit a Control Request to the driver.">cs35l41_functions_t.control</a> </p>

</div>
</div>
<a id="a34225c39fb480eb098b00ab4db08179f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34225c39fb480eb098b00ab4db08179f">&#9670;&nbsp;</a></span>cs35l41_control_q_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool cs35l41_control_q_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements 'copy' method for Control Request Queue contents. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#ae73dfdbfb9c0ba6a983e7614dc80ecce" title="Implements &#39;copy&#39; method for Control Request Queue contents.">cs35l41_private_functions_t.control_q_copy</a> </p>

</div>
</div>
<a id="adb027e711b6d0117c21a917f222a8ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb027e711b6d0117c21a917f222a8ae6">&#9670;&nbsp;</a></span>cs35l41_cp_bulk_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_cp_bulk_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads contents from a consecutive number of memory addresses. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#a6ef244557503ba25c60a8c55efab9143" title="Reads contents from a consecutive number of memory addresses.">cs35l41_private_functions_t.cp_bulk_read</a> </p>

</div>
</div>
<a id="a5cd25ed2a9f5db25c1fc54812efe135e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd25ed2a9f5db25c1fc54812efe135e">&#9670;&nbsp;</a></span>cs35l41_cp_bulk_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_cp_bulk_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes from byte array to consecutive number of Control Port memory addresses. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#aed22cf9c3bbf114381a09ff71ce3e83f" title="Writes from byte array to consecutive number of Control Port memory addresses.">cs35l41_private_functions_t.cp_bulk_write</a> </p>

</div>
</div>
<a id="afd032d344f67fffe64e55a79698d9771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd032d344f67fffe64e55a79698d9771">&#9670;&nbsp;</a></span>cs35l41_cp_read_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cs35l41_cp_read_callback </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the driver when the BSP Control Port (cp) read transaction completes. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#ad3bf56df199d403c8089a887ea7f15cb" title="Notify the driver when the BSP Control Port (cp) read transaction completes.">cs35l41_private_functions_t.cp_read_callback</a> </p>

</div>
</div>
<a id="ade122eb53e44fea974c18b194a6212e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade122eb53e44fea974c18b194a6212e7">&#9670;&nbsp;</a></span>cs35l41_cp_write_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cs35l41_cp_write_callback </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the driver when the BSP Control Port (cp) write transaction completes. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#ab26ee752fa42934fe64e1c41de78fcd2" title="Notify the driver when the BSP Control Port (cp) write transaction completes.">cs35l41_private_functions_t.cp_write_callback</a> </p>

</div>
</div>
<a id="afea3b5c90e2ff2d2089caa9bc8bdeeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea3b5c90e2ff2d2089caa9bc8bdeeca">&#9670;&nbsp;</a></span>cs35l41_event_sm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_event_sm </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Event Handler State Machine. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#a408ac75036fa1520638b85416fafd87e" title="Event Handler State Machine.">cs35l41_private_functions_t.event_sm</a> </p>

</div>
</div>
<a id="a6486e2ae0b69ee0d236ee2ac07f45a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6486e2ae0b69ee0d236ee2ac07f45a86">&#9670;&nbsp;</a></span>cs35l41_field_access_sm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_field_access_sm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Field Access State Machine. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#adf5875bc5a1914e54b4eb326ea9190bb" title="Field Access State Machine.">cs35l41_private_functions_t.field_access_sm</a> </p>

</div>
</div>
<a id="aa3fea52aa10c61908d49fe2867d0e6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fea52aa10c61908d49fe2867d0e6ab">&#9670;&nbsp;</a></span>cs35l41_get_dsp_status_sm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_get_dsp_status_sm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get DSP Status State Machine. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#a5e4b69bda2f1c574d0901b1120030a1a" title="Get DSP Status State Machine.">cs35l41_private_functions_t.get_dsp_status_sm</a> </p>

</div>
</div>
<a id="a5445bd2cf22c4e59374d41573ca32574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5445bd2cf22c4e59374d41573ca32574">&#9670;&nbsp;</a></span>cs35l41_get_errata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_get_errata </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>devid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>revid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t **&#160;</td>
          <td class="paramname"><em>errata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets pointer to correct errata based on DEVID/REVID. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#afaea1ee93a697281e0de22c40f67c61f" title="Gets pointer to correct errata based on DEVID/REVID.">cs35l41_private_functions_t.get_errata</a> </p>

</div>
</div>
<a id="a8db514b0ca993a10980292508e04d76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db514b0ca993a10980292508e04d76d">&#9670;&nbsp;</a></span>cs35l41_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cs35l41_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize driver state/handle. </p>
<p>Implementation of <a class="el" href="structcs35l41__functions__t.html#a3152cc7ad706858f8e2e2a8ae6367b13" title="Initialize driver state/handle.">cs35l41_functions_t.initialize</a> </p>

</div>
</div>
<a id="a52e6cf7260fb4f9029a46a869da5459c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e6cf7260fb4f9029a46a869da5459c">&#9670;&nbsp;</a></span>cs35l41_irq_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cs35l41_irq_callback </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the driver when the CS35L41 INTb GPIO drops low. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#a00a86ca59f74869cb7d706000231b316" title="Notify the driver when the CS35L41 INTb GPIO drops low.">cs35l41_private_functions_t.irq_callback</a> </p>

</div>
</div>
<a id="a88f68b4f63b412f6e9bfec7c42d75d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f68b4f63b412f6e9bfec7c42d75d24">&#9670;&nbsp;</a></span>cs35l41_irq_to_event_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_irq_to_event_id </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>irq_statuses</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps IRQ Flag to Event ID passed to BSP. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#a90c9558d529a5b92507dda7f770e8941" title="Maps IRQ Flag to Event ID passed to BSP.">cs35l41_private_functions_t.irq_to_event_id</a> </p>

</div>
</div>
<a id="a6f698d5cc802ae1a0aaa35ef2bcb371f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f698d5cc802ae1a0aaa35ef2bcb371f">&#9670;&nbsp;</a></span>cs35l41_is_control_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_is_control_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that the currently processed Control Request is valid for the current state of the driver. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#a1d8fe12fe7a6b0720da627aaa36cf4fa" title="Check that the currently processed Control Request is valid for the current state of the driver.">cs35l41_private_functions_t.is_control_valid</a> </p>

</div>
</div>
<a id="a24fbfdfa7902ffc35708f14d6658d32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fbfdfa7902ffc35708f14d6658d32f">&#9670;&nbsp;</a></span>cs35l41_is_mbox_status_correct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool cs35l41_is_mbox_status_correct </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check HALO MBOX Status against the MBOX Command sent. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#aacffd3273ff8f45695820f102fd75c72" title="Check HALO MBOX Status against the MBOX Command sent.">cs35l41_private_functions_t.is_mbox_status_correct</a> </p>

</div>
</div>
<a id="a78b78e24a8f4cdf5d4979a96a3f896ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b78e24a8f4cdf5d4979a96a3f896ee">&#9670;&nbsp;</a></span>cs35l41_is_mixer_source_used()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool cs35l41_is_mixer_source_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks all hardware mixer source selections for a specific source. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#a87a23b8eb3c811aba012b87508006b93" title="Checks all hardware mixer source selections for a specific source.">cs35l41_private_functions_t.is_mixer_source_used</a> </p>

</div>
</div>
<a id="a93893a759db17a077e6acfd433658b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93893a759db17a077e6acfd433658b40">&#9670;&nbsp;</a></span>cs35l41_load_control()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_load_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load new Control Request to be processed. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#aa07eeca75abaca69acc316d0591527a0" title="Load new Control Request to be processed.">cs35l41_private_functions_t.load_control</a> </p>

</div>
</div>
<a id="a83a149fe6daddf8abffbc085665df3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a149fe6daddf8abffbc085665df3ef">&#9670;&nbsp;</a></span>cs35l41_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cs35l41_power </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>power_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cs35l41_8h.html#a53bbdd9f24b4b7d8bd4fd33c3053ad8d">cs35l41_control_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the power state. </p>
<p>Implementation of <a class="el" href="structcs35l41__functions__t.html#a25573aaf132268b07fb8e86601656df6" title="Change the power state.">cs35l41_functions_t.power</a> </p>

</div>
</div>
<a id="a3844fee380afa9456ecbf8bb33759051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3844fee380afa9456ecbf8bb33759051">&#9670;&nbsp;</a></span>cs35l41_power_down_sm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_power_down_sm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Power Down State Machine. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#aa11935704b9da56c6e6fc2e79858ac41" title="Power Down State Machine.">cs35l41_private_functions_t.power_down_sm</a> </p>

</div>
</div>
<a id="a379e8b7396443d1f2a20711f6da4c8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379e8b7396443d1f2a20711f6da4c8f9">&#9670;&nbsp;</a></span>cs35l41_power_up_sm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_power_up_sm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Power Up State Machine. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#ad5d36b513f6e33a55fa8806cd85f7e17" title="Power Up State Machine.">cs35l41_private_functions_t.power_up_sm</a> </p>

</div>
</div>
<a id="a9035b122e866a3ee7ae60c00fd1cebb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9035b122e866a3ee7ae60c00fd1cebb1">&#9670;&nbsp;</a></span>cs35l41_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cs35l41_process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes driver state machines. </p>
<p>Implementation of <a class="el" href="structcs35l41__functions__t.html#a1ec305cac91e95257f1979f3ef0f584c" title="Processes driver state machines.">cs35l41_functions_t.process</a> </p>

</div>
</div>
<a id="ac930902102dc12afb7363844e579101f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac930902102dc12afb7363844e579101f">&#9670;&nbsp;</a></span>cs35l41_read_reg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_read_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the contents of a single register/memory address. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#ae6ae1e868279c613f34736c20a45d4f5" title="Reads the contents of a single register/memory address.">cs35l41_private_functions_t.read_reg</a> </p>

</div>
</div>
<a id="aea1e8a4a7cc9f91a0a380da67d9d5a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1e8a4a7cc9f91a0a380da67d9d5a48">&#9670;&nbsp;</a></span>cs35l41_reset_sm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_reset_sm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset State Machine. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#a515d10603ab119e901e6f821c726363e" title="Reset State Machine.">cs35l41_private_functions_t.reset_sm</a> </p>

</div>
</div>
<a id="a89ece368dc6278dae648c3d8378e2486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ece368dc6278dae648c3d8378e2486">&#9670;&nbsp;</a></span>cs35l41_timer_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cs35l41_timer_callback </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the driver when the BSP Timer expires. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#ae7ab34f9a1b2f9e40a0ebca901f54e20" title="Notify the driver when the BSP Timer expires.">cs35l41_private_functions_t.timer_callback</a> </p>

</div>
</div>
<a id="ae5ad67fea109bf2f3140f193c854d17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ad67fea109bf2f3140f193c854d17f">&#9670;&nbsp;</a></span>cs35l41_validate_boot_config()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_validate_boot_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__boot__config__t.html">cs35l41_boot_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_fw_boot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_coeff_boot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates the boot configuration provided by the BSP. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#a3a9fe55eb9babd92801872db7df24b8f" title="Validates the boot configuration provided by the BSP.">cs35l41_private_functions_t.validate_boot_config</a> </p>

</div>
</div>
<a id="a528751401192802a847b1732b6f8a416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528751401192802a847b1732b6f8a416">&#9670;&nbsp;</a></span>cs35l41_write_reg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cs35l41_write_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs35l41__t.html">cs35l41_t</a> *&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the contents of a single register/memory address. </p>
<p>Implementation of <a class="el" href="structcs35l41__private__functions__t.html#a4410e22074eeece6f37c48f8369067dd" title="Writes the contents of a single register/memory address.">cs35l41_private_functions_t.write_reg</a> </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a01e0f5f19a78b98e8006663b9f0148f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e0f5f19a78b98e8006663b9f0148f0">&#9670;&nbsp;</a></span>cs35l41_config_register_addresses</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t cs35l41_config_register_addresses[<a class="el" href="cs35l41_8h.html#aca640e23d80e448d463d234b5624922e">CS35L41_CONFIG_REGISTERS_TOTAL</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register addresses to modify during Configure SM. </p>
<p>Sent after the CS35L41 has been reset and, if firmware is available, has been booted.</p>
<p>List is in the form:</p><ul>
<li>word0 - Address of first configuration register</li>
<li>word1 - Address of second configuration register</li>
<li>...</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cs35l41_8c.html#a4e07b7824c082a5a2e2d7b856244a915" title="Configure State Machine.">cs35l41_configure_sm</a> </dd>
<dd>
<a class="el" href="structcs35l41__t.html" title="Driver state data structure.">cs35l41_t</a> member config_regs </dd>
<dd>
<a class="el" href="unioncs35l41__config__registers__t.html" title="Registers modified for amplifier configuration.">cs35l41_config_registers_t</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The list of registers MUST correspond to the union of structs in in <a class="el" href="unioncs35l41__config__registers__t.html" title="Registers modified for amplifier configuration.">cs35l41_config_registers_t</a>. </dd></dl>

</div>
</div>
<a id="a852e72d23608767f4636edfc4d2ee852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852e72d23608767f4636edfc4d2ee852">&#9670;&nbsp;</a></span>cs35l41_dsp_status_addresses</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t cs35l41_dsp_status_addresses[<a class="el" href="cs35l41_8h.html#a1196a694803be40d4177f6fec416195d">CS35L41_DSP_STATUS_WORDS_TOTAL</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register/DSP Memory addresses to read during Get DSP Status SM. </p>
<p>List is in the form:</p><ul>
<li>word0 - Address of first status register</li>
<li>word1 - Address of second status register</li>
<li>...</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cs35l41_8c.html#aa3fea52aa10c61908d49fe2867d0e6ab" title="Get DSP Status State Machine.">cs35l41_get_dsp_status_sm</a> </dd>
<dd>
<a class="el" href="structcs35l41__dsp__status__t.html" title="Status of HALO FW.">cs35l41_dsp_status_t</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The list of registers MUST correspond to the union of structs in in <a class="el" href="structcs35l41__dsp__status__t.html" title="Status of HALO FW.">cs35l41_dsp_status_t</a>. </dd></dl>

</div>
</div>
<a id="ab22054eab374b92a276f11d258b6585e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22054eab374b92a276f11d258b6585e">&#9670;&nbsp;</a></span>cs35l41_frame_sync_regs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t cs35l41_frame_sync_regs[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register addresses to set all HALO sample rates to the same value. </p>
<p>Sent just before the CS35L41 is powered up in Power Up SM. All register values will be set to CS35L41_DSP1_SAMPLE_RATE_G1R2.</p>
<p>List is in the form:</p><ul>
<li>word0 - Address of first configuration register</li>
<li>word1 - Address of second configuration register</li>
<li>...</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cs35l41_8c.html#a379e8b7396443d1f2a20711f6da4c8f9" title="Power Up State Machine.">cs35l41_power_up_sm</a> </dd>
<dd>
<a class="el" href="group___s_e_c_t_i_o_n__7__36___x_m___u_n_p_a_c_k_e_d24.html#ga6ff90c7268cf6a5aebd2269fd6747a64">CS35L41_DSP1_SAMPLE_RATE_G1R2</a> </dd></dl>

</div>
</div>
<a id="ac8dda85fac851b50d63353e1868fec98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8dda85fac851b50d63353e1868fec98">&#9670;&nbsp;</a></span>cs35l41_functions_s</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcs35l41__functions__t.html">cs35l41_functions_t</a> cs35l41_functions_s</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function pointer table for Public API implementation. </p>
<dl class="section attention"><dt>Attention</dt><dd>Although not const, this should never be changed run-time in an end-product. It is implemented this way to facilitate unit testing. </dd></dl>

</div>
</div>
<a id="a7aefb95b3e8696f351533db309f01d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aefb95b3e8696f351533db309f01d08">&#9670;&nbsp;</a></span>cs35l41_mem_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t cs35l41_mem_lock[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register configuration to lock HALO memory regions. </p>
<p>Sent just before the CS35L41 is powered up in Power Up SM.</p>
<p>List is in the form:</p><ul>
<li>word1 - address of DSP1_MPU_LOCK_CONFIG</li>
<li>word2 - 1st unlock value</li>
<li>word3 - address of DSP1_MPU_LOCK_CONFIG</li>
<li>word4 - 2nd unlock value</li>
<li>word5 - Address of first configuration register</li>
<li>word6 - Value of first configuration register</li>
<li>word7 - Address of second configuration register</li>
<li>word8 - Value of second configuration register</li>
<li>...</li>
<li>wordx - address of DSP1_MPU_LOCK_CONFIG</li>
<li>wordx - 1st lock value</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cs35l41_8c.html#a379e8b7396443d1f2a20711f6da4c8f9" title="Power Up State Machine.">cs35l41_power_up_sm</a> </dd></dl>

</div>
</div>
<a id="acd16ca37a9ad9072b9a8a81730ccc474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd16ca37a9ad9072b9a8a81730ccc474">&#9670;&nbsp;</a></span>cs35l41_otp_maps</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcs35l41__otp__map__t.html">cs35l41_otp_map_t</a> cs35l41_otp_maps[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of possible OTP Maps for CS35L41 RevB2. </p>
<p>For CS35L41 RevB2, the following values of OTPID are possible:</p><ul>
<li>0x1 - on used at first release of RevB2, this driver should not experience any in the field</li>
<li>0x8 - currently only common ID for this driver</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcs35l41__otp__map__t.html" title="Data structure describing an OTP Map.">cs35l41_otp_map_t</a> </dd></dl>

</div>
</div>
<a id="a80fc0210792d264448d59ec3c159096f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fc0210792d264448d59ec3c159096f">&#9670;&nbsp;</a></span>cs35l41_pdn_patch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t cs35l41_pdn_patch[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register configuration to send just after the CS35L41 is powered down in Power Down SM. </p>
<p>List is in the form:</p><ul>
<li>word1 - address of TEST_KEY_CTRL</li>
<li>word2 - 1st unlock value</li>
<li>word3 - address of TEST_KEY_CTRL</li>
<li>word4 - 2nd unlock value</li>
<li>word5 - Address of first configuration register</li>
<li>word6 - Value of first configuration register</li>
<li>word7 - Address of second configuration register</li>
<li>word8 - Value of second configuration register</li>
<li>...</li>
<li>wordx - address of TEST_KEY_CTRL</li>
<li>wordx - 1st lock value</li>
<li>wordx - address of TEST_KEY_CTRL</li>
<li>wordx - 2nd lock value</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cs35l41_8c.html#a3844fee380afa9456ecbf8bb33759051" title="Power Down State Machine.">cs35l41_power_down_sm</a> </dd></dl>

</div>
</div>
<a id="ac9efec6548c3cd9d46d2e7763b977fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9efec6548c3cd9d46d2e7763b977fde">&#9670;&nbsp;</a></span>cs35l41_post_boot_config</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t cs35l41_post_boot_config[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register configuration after HALO FW is loaded in Boot SM. </p>
<p>List is in the form:</p><ul>
<li>word0 - Address of first configuration register</li>
<li>word1 - Value of first configuration register</li>
<li>word2 - Address of second configuration register</li>
<li>word3 - Value of second configuration register</li>
<li>... </li>
</ul>

</div>
</div>
<a id="a41c87f06e30be9e9a0313fd8aab43344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c87f06e30be9e9a0313fd8aab43344">&#9670;&nbsp;</a></span>cs35l41_private_functions_s</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcs35l41__private__functions__t.html">cs35l41_private_functions_t</a> cs35l41_private_functions_s</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function pointer table for Private API implementation. </p>
<dl class="section attention"><dt>Attention</dt><dd>Although not const, this should never be changed run-time in an end-product. It is implemented this way to facilitate unit testing. </dd></dl>

</div>
</div>
<a id="a2f26adf842c5693aefc7672e8fae2377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f26adf842c5693aefc7672e8fae2377">&#9670;&nbsp;</a></span>cs35l41_pup_patch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t cs35l41_pup_patch[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register configuration to send just before the CS35L41 is powered up in Power Up SM. </p>
<p>List is in the form:</p><ul>
<li>word1 - address of TEST_KEY_CTRL</li>
<li>word2 - 1st unlock value</li>
<li>word3 - address of TEST_KEY_CTRL</li>
<li>word4 - 2nd unlock value</li>
<li>word5 - Address of first configuration register</li>
<li>word6 - Value of first configuration register</li>
<li>word7 - Address of second configuration register</li>
<li>word8 - Value of second configuration register</li>
<li>...</li>
<li>wordx - address of TEST_KEY_CTRL</li>
<li>wordx - 1st lock value</li>
<li>wordx - address of TEST_KEY_CTRL</li>
<li>wordx - 2nd lock value</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cs35l41_8c.html#a379e8b7396443d1f2a20711f6da4c8f9" title="Power Up State Machine.">cs35l41_power_up_sm</a> </dd></dl>

</div>
</div>
<a id="acbb00b021aae35d40c35832963ec95a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb00b021aae35d40c35832963ec95a3">&#9670;&nbsp;</a></span>cs35l41_revb0_errata_patch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t cs35l41_revb0_errata_patch[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CS35L41 RevB0 Register Patch Errata. </p>
<p>The array is in the form:</p><ul>
<li>word0 - Length of rest of patch in words (i.e. NOT including this word)</li>
<li>word1 - address of TEST_KEY_CTRL</li>
<li>word2 - 1st unlock value</li>
<li>word3 - address of TEST_KEY_CTRL</li>
<li>word4 - 2nd unlock value</li>
<li>word5 - 1st register address to patch</li>
<li>word6 - 1st register value</li>
<li>word7 - 2nd register address to patch</li>
<li>word8 - 2nd register value</li>
<li>...</li>
<li>wordx - address of TEST_KEY_CTRL</li>
<li>wordx - 1st lock value</li>
<li>wordx - address of TEST_KEY_CTRL</li>
<li>wordx - 2nd lock value</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>To simplify the Reset SM, this includes the configuration for IRQ1 and INTb GPIO </dd></dl>

</div>
</div>
<a id="ac503fe04b98cb8063ca6a6d184d0b2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac503fe04b98cb8063ca6a6d184d0b2c3">&#9670;&nbsp;</a></span>irq_masks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t irq_masks[4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache for contents of IRQ1_MASK_*_REG interrupt mask registers. </p>
<p>Currently, the following registers are cached:</p><ul>
<li>IRQ1_IRQ1_MASK_1_REG</li>
<li>IRQ1_IRQ1_MASK_2_REG</li>
<li>IRQ1_IRQ1_MASK_3_REG</li>
<li>IRQ1_IRQ1_MASK_4_REG</li>
</ul>
<p>This cache is required for cs35l41_event_sm. It is used along with irq_statuses[] to determine what unmasked interrupts have occurred. The cache currently is not allocated as part of <a class="el" href="structcs35l41__t.html" title="Driver state data structure.">cs35l41_t</a>, but it should either be allocated there or have another means to cache the contents.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_e_c_t_i_o_n__7__23___i_r_q1.html#gaf3694b5f989ff3a9094c1d7a3f6af2e4">IRQ1_IRQ1_MASK_1_REG</a> </dd>
<dd>
IRQ1_IRQ1_MASK_2_REG </dd>
<dd>
IRQ1_IRQ1_MASK_3_REG </dd>
<dd>
IRQ1_IRQ1_MASK_4_REG </dd>
<dd>
<a class="el" href="cs35l41_8c.html#afea3b5c90e2ff2d2089caa9bc8bdeeca" title="Event Handler State Machine.">cs35l41_event_sm</a> </dd></dl>

</div>
</div>
<a id="a93ed7ca914fe1948b5d02bdf1b1c0083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ed7ca914fe1948b5d02bdf1b1c0083">&#9670;&nbsp;</a></span>irq_statuses</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t irq_statuses[4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache for contents of IRQ1_EINT_*_REG interrupt flag registers. </p>
<p>Currently, the following registers are cached:</p><ul>
<li>IRQ1_IRQ1_EINT_1_REG</li>
<li>IRQ1_IRQ1_EINT_2_REG</li>
<li>IRQ1_IRQ1_EINT_3_REG</li>
<li>IRQ1_IRQ1_EINT_4_REG</li>
</ul>
<p>This cache is required for cs35l41_event_sm. It is used along with irq_masks[] to determine what unmasked interrupts have occurred. This cache is required for cs35l41_event_sm. The cache currently is not allocated as part of <a class="el" href="structcs35l41__t.html" title="Driver state data structure.">cs35l41_t</a>, but it should either be allocated there or have another means to cache the contents.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_e_c_t_i_o_n__7__23___i_r_q1.html#gab23ec53b518785be0666c6447331dcdb">IRQ1_IRQ1_EINT_1_REG</a> </dd>
<dd>
<a class="el" href="group___s_e_c_t_i_o_n__7__23___i_r_q1.html#ga1ef32b2954f3526f6215a2d4d14d3b84">IRQ1_IRQ1_EINT_2_REG</a> </dd>
<dd>
IRQ1_IRQ1_EINT_3_REG </dd>
<dd>
IRQ1_IRQ1_EINT_4_REG </dd>
<dd>
<a class="el" href="cs35l41_8c.html#afea3b5c90e2ff2d2089caa9bc8bdeeca" title="Event Handler State Machine.">cs35l41_event_sm</a> </dd></dl>

</div>
</div>
<a id="a76b5e16399942433e00eb52bc96e21fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b5e16399942433e00eb52bc96e21fb">&#9670;&nbsp;</a></span>otp_map_1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcs35l41__otp__packed__entry__t.html">cs35l41_otp_packed_entry_t</a> otp_map_1[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CS35L41 RevB2 OTP Map 1. </p>
<p>This mapping below maps the OTP bitfields of varying sizes to the Control Port register bitfields OTP is to trim.</p>
<p>This is a list in the form <a class="el" href="structcs35l41__otp__packed__entry__t.html" title="Entry in OTP Map of packed bitfield entries.">cs35l41_otp_packed_entry_t</a>, which is: { {Register Address, Bitwise Shift, Bitwise Size} //For first OTP bitfield {Register Address, Bitwise Shift, Bitwise Size} //For second OTP bitfield ... }</p>
<p>Corresponds to OTPID 0x8</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcs35l41__otp__packed__entry__t.html" title="Entry in OTP Map of packed bitfield entries.">cs35l41_otp_packed_entry_t</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
