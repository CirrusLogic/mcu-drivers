<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: cs35l41_functions_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structcs35l41__functions__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cs35l41_functions_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Driver public API.  
 <a href="structcs35l41__functions__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cs35l41_8h_source.html">cs35l41.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3152cc7ad706858f8e2e2a8ae6367b13"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__functions__t.html#a3152cc7ad706858f8e2e2a8ae6367b13">initialize</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a3152cc7ad706858f8e2e2a8ae6367b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize driver state/handle.  <a href="structcs35l41__functions__t.html#a3152cc7ad706858f8e2e2a8ae6367b13">More...</a><br /></td></tr>
<tr class="separator:a3152cc7ad706858f8e2e2a8ae6367b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9806ed5b318b282c83bf93c994ba2a43"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__functions__t.html#a9806ed5b318b282c83bf93c994ba2a43">configure</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, <a class="el" href="structcs35l41__config__t.html">cs35l41_config_t</a> *config)</td></tr>
<tr class="memdesc:a9806ed5b318b282c83bf93c994ba2a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures driver state/handle.  <a href="structcs35l41__functions__t.html#a9806ed5b318b282c83bf93c994ba2a43">More...</a><br /></td></tr>
<tr class="separator:a9806ed5b318b282c83bf93c994ba2a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec305cac91e95257f1979f3ef0f584c"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__functions__t.html#a1ec305cac91e95257f1979f3ef0f584c">process</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td></tr>
<tr class="memdesc:a1ec305cac91e95257f1979f3ef0f584c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes driver state machines.  <a href="structcs35l41__functions__t.html#a1ec305cac91e95257f1979f3ef0f584c">More...</a><br /></td></tr>
<tr class="separator:a1ec305cac91e95257f1979f3ef0f584c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ef4444485f6f7f0151987dec3b62da"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__functions__t.html#a27ef4444485f6f7f0151987dec3b62da">control</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, <a class="el" href="structcs35l41__control__request__t.html">cs35l41_control_request_t</a> req)</td></tr>
<tr class="memdesc:a27ef4444485f6f7f0151987dec3b62da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a Control Request to the driver.  <a href="structcs35l41__functions__t.html#a27ef4444485f6f7f0151987dec3b62da">More...</a><br /></td></tr>
<tr class="separator:a27ef4444485f6f7f0151987dec3b62da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89a3cbb49b0bb687fc201ccace406cc"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__functions__t.html#ac89a3cbb49b0bb687fc201ccace406cc">boot</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, <a class="el" href="cs35l41_8h.html#a53bbdd9f24b4b7d8bd4fd33c3053ad8d">cs35l41_control_callback_t</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ac89a3cbb49b0bb687fc201ccace406cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot the CS35L41.  <a href="structcs35l41__functions__t.html#ac89a3cbb49b0bb687fc201ccace406cc">More...</a><br /></td></tr>
<tr class="separator:ac89a3cbb49b0bb687fc201ccace406cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25573aaf132268b07fb8e86601656df6"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__functions__t.html#a25573aaf132268b07fb8e86601656df6">power</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t power_state, <a class="el" href="cs35l41_8h.html#a53bbdd9f24b4b7d8bd4fd33c3053ad8d">cs35l41_control_callback_t</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a25573aaf132268b07fb8e86601656df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the power state.  <a href="structcs35l41__functions__t.html#a25573aaf132268b07fb8e86601656df6">More...</a><br /></td></tr>
<tr class="separator:a25573aaf132268b07fb8e86601656df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fa0dbd155a06e0f45540b99d00c88d"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs35l41__functions__t.html#ab8fa0dbd155a06e0f45540b99d00c88d">calibrate</a> )(<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t ambient_temp_deg_c, <a class="el" href="cs35l41_8h.html#a53bbdd9f24b4b7d8bd4fd33c3053ad8d">cs35l41_control_callback_t</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ab8fa0dbd155a06e0f45540b99d00c88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrate the HALO DSP Protection Algorithm.  <a href="structcs35l41__functions__t.html#ab8fa0dbd155a06e0f45540b99d00c88d">More...</a><br /></td></tr>
<tr class="separator:ab8fa0dbd155a06e0f45540b99d00c88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Driver public API. </p>
<p>All API calls require a handle (<a class="el" href="structcs35l41__t.html" title="Driver state data structure.">cs35l41_t</a> *) to the driver state. All API calls return a status </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_s35_l41___s_t_a_t_u_s__.html" title="Return values for all public and most private API calls.">CS35L41_STATUS_</a></dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The <a class="el" href="structcs35l41__functions__t.html#a1ec305cac91e95257f1979f3ef0f584c" title="Processes driver state machines.">process()</a> API must be called in either (1) a baremetal superloop or (2) an RTOS task loop in order to execute the following APIs:<ul>
<li><a class="el" href="structcs35l41__functions__t.html#a27ef4444485f6f7f0151987dec3b62da" title="Submit a Control Request to the driver.">control()</a></li>
<li><a class="el" href="structcs35l41__functions__t.html#ac89a3cbb49b0bb687fc201ccace406cc" title="Boot the CS35L41.">boot()</a></li>
<li><a class="el" href="structcs35l41__functions__t.html#a25573aaf132268b07fb8e86601656df6" title="Change the power state.">power()</a></li>
<li><a class="el" href="structcs35l41__functions__t.html#ab8fa0dbd155a06e0f45540b99d00c88d" title="Calibrate the HALO DSP Protection Algorithm.">calibrate()</a> </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="ac89a3cbb49b0bb687fc201ccace406cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89a3cbb49b0bb687fc201ccace406cc">&#9670;&nbsp;</a></span>boot</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_functions_t::boot) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, <a class="el" href="cs35l41_8h.html#a53bbdd9f24b4b7d8bd4fd33c3053ad8d">cs35l41_control_callback_t</a> cb, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boot the CS35L41. </p>
<p>Boot may include stepping through the following state machines:</p><ul>
<li>Reset SM - toggle RESET GPIO, unpack and apply OTP trims, HW configuration</li>
<li>Boot SM - load a HALO DSP FW image and COEFF image</li>
<li>Configure SM - apply the driver configuration to the CS35L41 register file</li>
</ul>
<p>This function is essentially an alias for multiple calls to cs35l41_control - it submits Control Requests for the controls above that apply to the current driver configuration.</p>
<dl class="section attention"><dt>Attention</dt><dd>It should be noted that the callback <b>cb</b> will be called upon completion (either successful or unsuccessful) of <b>each</b> Control Request when booting. Thus the caller could get the callback called for RESET, BOOT, and CONFIGURE controls.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback for completion of each control stage of boot process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>Pointer to argument to use for callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if any submission of Control Request failed</li>
<li>CS35L41_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab8fa0dbd155a06e0f45540b99d00c88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8fa0dbd155a06e0f45540b99d00c88d">&#9670;&nbsp;</a></span>calibrate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_functions_t::calibrate) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t ambient_temp_deg_c, <a class="el" href="cs35l41_8h.html#a53bbdd9f24b4b7d8bd4fd33c3053ad8d">cs35l41_control_callback_t</a> cb, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calibrate the HALO DSP Protection Algorithm. </p>
<p>This performs the calibration procedure required for CSPL Protection Algorithm to obtain the currently measured speaker load impedance. This calibration information (<a class="el" href="structcs35l41__calibration__t.html" title="State of HALO FW Calibration.">cs35l41_calibration_t</a>) will be saved in the driver state and applied during subsequent boots of the part. This calibration information will be available to the driver until the driver is re-initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ambient_temp_deg_c</td><td>Current Ambient Temperature in degrees Celsius </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback for completion of each control stage of boot process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>Pointer to argument to use for callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if submission of Control Request failed</li>
<li>CS35L41_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcs35l41__calibration__t.html" title="State of HALO FW Calibration.">cs35l41_calibration_t</a> </dd></dl>

</div>
</div>
<a id="a9806ed5b318b282c83bf93c994ba2a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9806ed5b318b282c83bf93c994ba2a43">&#9670;&nbsp;</a></span>configure</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_functions_t::configure) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, <a class="el" href="structcs35l41__config__t.html">cs35l41_config_t</a> *config)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures driver state/handle. </p>
<p>Including the following:</p><ul>
<li>Applies all one-time configurations to the driver state</li>
<li>Registers the IRQ Callback for INTb GPIO with the BSP</li>
<li>Applies calibration data (if valid) to the driver state</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to driver configuration data structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if any pointers are NULL</li>
<li>CS35L41_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a27ef4444485f6f7f0151987dec3b62da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ef4444485f6f7f0151987dec3b62da">&#9670;&nbsp;</a></span>control</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_functions_t::control) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, <a class="el" href="structcs35l41__control__request__t.html">cs35l41_control_request_t</a> req)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a Control Request to the driver. </p>
<p>Caller will initialize a <a class="el" href="structcs35l41__control__request__t.html" title="Data structure to describe a Control Request.">cs35l41_control_request_t</a> 'req' based on the control it wishes to access. This request will then be added to the Control Request Queue, and the callback given in 'req' will be called once either:</p><ul>
<li>the Control Request has completed successfully</li>
<li>there was an ERROR when executing the Control Request</li>
<li>the Control Request is invalid for the current driver state</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>data structure for control request <b>passed</b> by value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if Control Request ID is invalid OR if insertion into Control Request Queue failed</li>
<li>CS35L41_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcs35l41__control__request__t.html" title="Data structure to describe a Control Request.">cs35l41_control_request_t</a> </dd></dl>

</div>
</div>
<a id="a3152cc7ad706858f8e2e2a8ae6367b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3152cc7ad706858f8e2e2a8ae6367b13">&#9670;&nbsp;</a></span>initialize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_functions_t::initialize) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize driver state/handle. </p>
<p>Sets all driver state members to 0, and initializes Control Request Queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if call to <a class="el" href="structf__queue__if__t.html" title="Fixed Queue public API.">f_queue_if_t</a> fails</li>
<li>CS35L41_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a25573aaf132268b07fb8e86601656df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25573aaf132268b07fb8e86601656df6">&#9670;&nbsp;</a></span>power</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_functions_t::power) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver, uint32_t power_state, <a class="el" href="cs35l41_8h.html#a53bbdd9f24b4b7d8bd4fd33c3053ad8d">cs35l41_control_callback_t</a> cb, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the power state. </p>
<p>This submits a Control Request to either Power Up or Power Down the CS35L41. Although there is no checking here for whether the request is invalid (i.e. Power Down when the driver state is already STANDBY), this checking will be performed once the request is loaded in <a class="el" href="cs35l41_8c.html#a9035b122e866a3ee7ae60c00fd1cebb1" title="Processes driver state machines.">cs35l41_process()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">power_state</td><td>New power state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback for completion of each control stage of boot process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>Pointer to argument to use for callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS35L41_STATUS_FAIL if submission of Control Request failed</li>
<li>CS35L41_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1ec305cac91e95257f1979f3ef0f584c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec305cac91e95257f1979f3ef0f584c">&#9670;&nbsp;</a></span>process</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs35l41_functions_t::process) (<a class="el" href="structcs35l41__t.html">cs35l41_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes driver state machines. </p>
<p>This implements the 'CS35L41 Process Flowchart' found in the driver Tech Note. This includes:</p><ul>
<li>calling Event Handler SM if in HANDLING_EVENTS mode</li>
<li>calling current Control SM if in HANLDING_CONTROLS mode</li>
<li>loading new controls and checking validity per driver state</li>
<li>calling BSP callbacks upon completion of Control Requests</li>
<li>handling Control Request errors</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>if in UNCONFIGURED or ERROR state, returns CS35L41_STATUS_OK</li>
<li>else if in HANDLING_CONTROLS mode and not currently processing Control SM&lt; returns CS35L41_STATUS_OK</li>
<li>otherwise, returns status from any state machine executed (either Event Handler or Control SM)</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This MUST be placed either in baremetal or RTOS task while (1) </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="cs35l41_8h_source.html">cs35l41.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
