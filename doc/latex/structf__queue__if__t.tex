\hypertarget{structf__queue__if__t}{}\doxysection{f\+\_\+queue\+\_\+if\+\_\+t Struct Reference}
\label{structf__queue__if__t}\index{f\_queue\_if\_t@{f\_queue\_if\_t}}


Fixed Queue public A\+PI.  




{\ttfamily \#include $<$f\+\_\+queue.\+h$>$}

\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t($\ast$ \mbox{\hyperlink{structf__queue__if__t_a941a78ae6215814210f01685d2672f9f}{initialize}} )(\mbox{\hyperlink{structf__queue__t}{f\+\_\+queue\+\_\+t}} $\ast$q, uint32\+\_\+t size, void $\ast$elements, uint8\+\_\+t element\+\_\+size\+\_\+bytes, \mbox{\hyperlink{f__queue_8h_abedd0d023ee1ed717ab173baae6a2d3b}{f\+\_\+queue\+\_\+copy}} cp)
\begin{DoxyCompactList}\small\item\em Initialize the Queue. \end{DoxyCompactList}\item 
uint32\+\_\+t($\ast$ \mbox{\hyperlink{structf__queue__if__t_a107b58df7a3ebb51c863cf1800d8f750}{insert}} )(\mbox{\hyperlink{structf__queue__t}{f\+\_\+queue\+\_\+t}} $\ast$, void $\ast$)
\begin{DoxyCompactList}\small\item\em Insert an element into the Queue. \end{DoxyCompactList}\item 
uint32\+\_\+t($\ast$ \mbox{\hyperlink{structf__queue__if__t_a5ce5a57d50530c185a3e610237c7b64e}{remove}} )(\mbox{\hyperlink{structf__queue__t}{f\+\_\+queue\+\_\+t}} $\ast$, void $\ast$)
\begin{DoxyCompactList}\small\item\em Remove an element from the Queue. \end{DoxyCompactList}\item 
uint32\+\_\+t($\ast$ \mbox{\hyperlink{structf__queue__if__t_abb5e70c97a5af1db096a1b3749ca21db}{flush}} )(\mbox{\hyperlink{structf__queue__t}{f\+\_\+queue\+\_\+t}} $\ast$)
\begin{DoxyCompactList}\small\item\em Flush (delete all elements) from the Queue. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Fixed Queue public A\+PI. 

All A\+PI calls require a handle (\mbox{\hyperlink{structf__queue__t}{f\+\_\+queue\+\_\+t}} $\ast$) to the queueu handling data structure. All A\+PI calls return a status \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{group___f___q_u_e_u_e___s_t_a_t_u_s__}{F\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+}} 
\end{DoxySeeAlso}


\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{structf__queue__if__t_abb5e70c97a5af1db096a1b3749ca21db}\label{structf__queue__if__t_abb5e70c97a5af1db096a1b3749ca21db}} 
\index{f\_queue\_if\_t@{f\_queue\_if\_t}!flush@{flush}}
\index{flush@{flush}!f\_queue\_if\_t@{f\_queue\_if\_t}}
\doxysubsubsection{\texorpdfstring{flush}{flush}}
{\footnotesize\ttfamily uint32\+\_\+t($\ast$ f\+\_\+queue\+\_\+if\+\_\+t\+::flush) (\mbox{\hyperlink{structf__queue__t}{f\+\_\+queue\+\_\+t}} $\ast$)}



Flush (delete all elements) from the Queue. 

After a flush, the queue will be empty


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em q} & pointer to the queue handling structure\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item F\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+IL if pointer is N\+U\+LL
\item F\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK otherwise 
\end{DoxyItemize}
\end{DoxyReturn}
\mbox{\Hypertarget{structf__queue__if__t_a941a78ae6215814210f01685d2672f9f}\label{structf__queue__if__t_a941a78ae6215814210f01685d2672f9f}} 
\index{f\_queue\_if\_t@{f\_queue\_if\_t}!initialize@{initialize}}
\index{initialize@{initialize}!f\_queue\_if\_t@{f\_queue\_if\_t}}
\doxysubsubsection{\texorpdfstring{initialize}{initialize}}
{\footnotesize\ttfamily uint32\+\_\+t($\ast$ f\+\_\+queue\+\_\+if\+\_\+t\+::initialize) (\mbox{\hyperlink{structf__queue__t}{f\+\_\+queue\+\_\+t}} $\ast$q, uint32\+\_\+t size, void $\ast$elements, uint8\+\_\+t element\+\_\+size\+\_\+bytes, \mbox{\hyperlink{f__queue_8h_abedd0d023ee1ed717ab173baae6a2d3b}{f\+\_\+queue\+\_\+copy}} cp)}



Initialize the Queue. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em q} & pointer to the queue handling structure \\
\hline
\mbox{\texttt{ in}}  & {\em size} & size of queue element storage already allocated \\
\hline
\mbox{\texttt{ in}}  & {\em elements} & pointer to queue element storage \\
\hline
\mbox{\texttt{ in}}  & {\em element\+\_\+size\+\_\+bytes} & size of queue element in bytes \\
\hline
\mbox{\texttt{ in}}  & {\em cp} & pointer to queue element copy method implementation\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item F\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+IL if any pointers are N\+U\+LL or if the size is $<$= 0
\item F\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK otherwise 
\end{DoxyItemize}
\end{DoxyReturn}
\mbox{\Hypertarget{structf__queue__if__t_a107b58df7a3ebb51c863cf1800d8f750}\label{structf__queue__if__t_a107b58df7a3ebb51c863cf1800d8f750}} 
\index{f\_queue\_if\_t@{f\_queue\_if\_t}!insert@{insert}}
\index{insert@{insert}!f\_queue\_if\_t@{f\_queue\_if\_t}}
\doxysubsubsection{\texorpdfstring{insert}{insert}}
{\footnotesize\ttfamily uint32\+\_\+t($\ast$ f\+\_\+queue\+\_\+if\+\_\+t\+::insert) (\mbox{\hyperlink{structf__queue__t}{f\+\_\+queue\+\_\+t}} $\ast$, void $\ast$)}



Insert an element into the Queue. 

\begin{DoxyAttention}{Attention}
Queue insertion copies the contents into queue storage.
\end{DoxyAttention}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em q} & pointer to the queue handling structure \\
\hline
\mbox{\texttt{ in}}  & {\em new\+\_\+element\+\_\+ptr} & pointer to queue element to be inserted\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item F\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+IL if any pointers are N\+U\+LL, if the queue is full, or if the copy fails
\item F\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK otherwise 
\end{DoxyItemize}
\end{DoxyReturn}
\mbox{\Hypertarget{structf__queue__if__t_a5ce5a57d50530c185a3e610237c7b64e}\label{structf__queue__if__t_a5ce5a57d50530c185a3e610237c7b64e}} 
\index{f\_queue\_if\_t@{f\_queue\_if\_t}!remove@{remove}}
\index{remove@{remove}!f\_queue\_if\_t@{f\_queue\_if\_t}}
\doxysubsubsection{\texorpdfstring{remove}{remove}}
{\footnotesize\ttfamily uint32\+\_\+t($\ast$ f\+\_\+queue\+\_\+if\+\_\+t\+::remove) (\mbox{\hyperlink{structf__queue__t}{f\+\_\+queue\+\_\+t}} $\ast$, void $\ast$)}



Remove an element from the Queue. 

\begin{DoxyAttention}{Attention}
Queue removal copies the contents from queue storage.
\end{DoxyAttention}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em q} & pointer to the queue handling structure \\
\hline
\mbox{\texttt{ in}}  & {\em element\+\_\+ptr} & pointer to queue element to copy removed element\textquotesingle{}s contents\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item F\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+IL if any pointers are N\+U\+LL, if the queue is empty, or if the copy fails
\item F\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+OK otherwise 
\end{DoxyItemize}
\end{DoxyReturn}


The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
E\+:/jenkins/workspace/prince\+\_\+alt\+\_\+os\+\_\+nightly@2/common/\mbox{\hyperlink{f__queue_8h}{f\+\_\+queue.\+h}}\end{DoxyCompactItemize}
