<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CS40L25 MCU Driver Software Package: CS40L25_SM_STATE_</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CS40L25 MCU Driver Software Package
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">CS40L25_SM_STATE_</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic states used for all child state machines.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___c_s40_l25___e_v_e_n_t___s_m___s_t_a_t_e__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___e_v_e_n_t___s_m___s_t_a_t_e__.html">CS40L25_EVENT_SM_STATE_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___e_v_e_n_t___s_m___s_t_a_t_e__"><td class="mdescLeft">&#160;</td><td class="mdescRight">States for the Event Handler state machine. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___r_e_s_e_t___s_m___s_t_a_t_e__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___r_e_s_e_t___s_m___s_t_a_t_e__.html">CS40L25_RESET_SM_STATE_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___r_e_s_e_t___s_m___s_t_a_t_e__"><td class="mdescLeft">&#160;</td><td class="mdescRight">States for the Reset state machine. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___b_o_o_t___s_m___s_t_a_t_e__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___b_o_o_t___s_m___s_t_a_t_e__.html">CS40L25_BOOT_SM_STATE_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___b_o_o_t___s_m___s_t_a_t_e__"><td class="mdescLeft">&#160;</td><td class="mdescRight">States for the Boot state machine. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___p_o_w_e_r___u_p___s_m___s_t_a_t_e__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___p_o_w_e_r___u_p___s_m___s_t_a_t_e__.html">CS40L25_POWER_UP_SM_STATE_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___p_o_w_e_r___u_p___s_m___s_t_a_t_e__"><td class="mdescLeft">&#160;</td><td class="mdescRight">States for the Power Up state machine. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___p_o_w_e_r___d_o_w_n___s_m___s_t_a_t_e__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___p_o_w_e_r___d_o_w_n___s_m___s_t_a_t_e__.html">CS40L25_POWER_DOWN_SM_STATE_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___p_o_w_e_r___d_o_w_n___s_m___s_t_a_t_e__"><td class="mdescLeft">&#160;</td><td class="mdescRight">States for the Power Down state machine. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___c_o_n_f_i_g_u_r_e___s_m___s_t_a_t_e__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___c_o_n_f_i_g_u_r_e___s_m___s_t_a_t_e__.html">CS40L25_CONFIGURE_SM_STATE_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___c_o_n_f_i_g_u_r_e___s_m___s_t_a_t_e__"><td class="mdescLeft">&#160;</td><td class="mdescRight">States for the Configure state machine. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___f_i_e_l_d___a_c_c_e_s_s___s_m___s_t_a_t_e__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___f_i_e_l_d___a_c_c_e_s_s___s_m___s_t_a_t_e__.html">CS40L25_FIELD_ACCESS_SM_STATE_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___f_i_e_l_d___a_c_c_e_s_s___s_m___s_t_a_t_e__"><td class="mdescLeft">&#160;</td><td class="mdescRight">States for the Field Access state machine. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___c_a_l_i_b_r_a_t_i_o_n___s_m___s_t_a_t_e__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___c_a_l_i_b_r_a_t_i_o_n___s_m___s_t_a_t_e__.html">CS40L25_CALIBRATION_SM_STATE_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___c_a_l_i_b_r_a_t_i_o_n___s_m___s_t_a_t_e__"><td class="mdescLeft">&#160;</td><td class="mdescRight">States for the Calibration state machine. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___g_e_t___d_s_p___s_t_a_t_u_s___s_m___s_t_a_t_e__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___g_e_t___d_s_p___s_t_a_t_u_s___s_m___s_t_a_t_e__.html">CS40L25_GET_DSP_STATUS_SM_STATE_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___g_e_t___d_s_p___s_t_a_t_u_s___s_m___s_t_a_t_e__"><td class="mdescLeft">&#160;</td><td class="mdescRight">States for the Get DSP Status state machine. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___f_l_a_g_s__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___f_l_a_g_s__.html">CS40L25_FLAGS_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___f_l_a_g_s__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags set by ISRs used to trigger transitions in state machines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___c_o_n_t_r_o_l___i_d__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___c_o_n_t_r_o_l___i_d__.html">CS40L25_CONTROL_ID_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___c_o_n_t_r_o_l___i_d__"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID to indicate the type of Control Request. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___d_s_p___m_b_o_x___s_t_a_t_u_s__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___d_s_p___m_b_o_x___s_t_a_t_u_s__.html">CS40L25_DSP_MBOX_STATUS_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___d_s_p___m_b_o_x___s_t_a_t_u_s__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statuses of the HALO DSP Mailbox. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___d_s_p___m_b_o_x___c_m_d__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___d_s_p___m_b_o_x___c_m_d__.html">CS40L25_DSP_MBOX_CMD_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___d_s_p___m_b_o_x___c_m_d__"><td class="mdescLeft">&#160;</td><td class="mdescRight">HALO DSP Mailbox commands. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___p_o_w_e_r__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___p_o_w_e_r__.html">CS40L25_POWER_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___p_o_w_e_r__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power states passed on to power() API argument power_state. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___c_a_l_i_b__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___c_a_l_i_b__.html">CS40L25_CALIB_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___c_a_l_i_b__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibration options passed on to calibrate() API argument calib_type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___e_v_e_n_t___f_l_a_g__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___e_v_e_n_t___f_l_a_g__.html">CS40L25_EVENT_FLAG_</a></td></tr>
<tr class="memdesc:group___c_s40_l25___e_v_e_n_t___f_l_a_g__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags passed to Notification Callback to notify BSP of specific driver events. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___c_s40_l25___f_l_a_g___m_a_c_r_o_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___f_l_a_g___m_a_c_r_o_s.html">CS40L25_FLAG_MACROS</a></td></tr>
<tr class="memdesc:group___c_s40_l25___f_l_a_g___m_a_c_r_o_s"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macros to get/set bitfield flags. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__halo__boot__file__t.html">cs40l25_halo_boot_file_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for lists of halo blocks used by cs40l24_boot_config_t.  <a href="structcs40l25__halo__boot__file__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__boot__config__t.html">cs40l25_boot_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure to describe HALO firmware and coefficient download.  <a href="structcs40l25__boot__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__sm__t.html">cs40l25_sm_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure describing driver control state machine implementation.  <a href="structcs40l25__sm__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__control__request__t.html">cs40l25_control_request_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure to describe a Control Request.  <a href="structcs40l25__control__request__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__field__accessor__t.html">cs40l25_field_accessor_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure to describe a field to read via the Field Access SM.  <a href="structcs40l25__field__accessor__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__audio__hw__config__t.html">cs40l25_audio_hw_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration of amplifier audio hardware.  <a href="structcs40l25__audio__hw__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__asp__config__t.html">cs40l25_asp_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration of amplifier Audio Serial Port (ASP)  <a href="structcs40l25__asp__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__routing__config__t.html">cs40l25_routing_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routing of audio data to Amplifier DAC, DSP, and ASP TX channels.  <a href="structcs40l25__routing__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__clock__config__t.html">cs40l25_clock_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration of internal clocking.  <a href="structcs40l25__clock__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__audio__config__t.html">cs40l25_audio_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of audio-related configurations.  <a href="structcs40l25__audio__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__amp__config__t.html">cs40l25_amp_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amplifier-related configurations.  <a href="structcs40l25__amp__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncs40l25__config__registers__t.html">cs40l25_config_registers_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers modified for amplifier configuration.  <a href="unioncs40l25__config__registers__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__dsp__config__controls__t.html">cs40l25_dsp_config_controls_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of firmware controls configured through <a class="el" href="structcs40l25__config__t.html" title="Driver configuration data structure.">cs40l25_config_t</a>.  <a href="structcs40l25__dsp__config__controls__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__calibration__t.html">cs40l25_calibration_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of HALO FW Calibration.  <a href="structcs40l25__calibration__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__dsp__status__t.html">cs40l25_dsp_status_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status of HALO FW.  <a href="structcs40l25__dsp__status__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__fw__revision__t.html">cs40l25_fw_revision_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__t.html">cs40l25_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver state data structure.  <a href="structcs40l25__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__config__t.html">cs40l25_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver configuration data structure.  <a href="structcs40l25__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__functions__t.html">cs40l25_functions_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver public API.  <a href="structcs40l25__functions__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcs40l25__private__functions__t.html">cs40l25_private_functions_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver private API.  <a href="structcs40l25__private__functions__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf81a310e60e333cb9048a9207cbc318c"><td class="memItemLeft" align="right" valign="top"><a id="gaf81a310e60e333cb9048a9207cbc318c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CS40L25_SM_STATE_INIT</b></td></tr>
<tr class="separator:gaf81a310e60e333cb9048a9207cbc318c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05b8dae4e35062e4ff079b0bca89480b"><td class="memItemLeft" align="right" valign="top"><a id="ga05b8dae4e35062e4ff079b0bca89480b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CS40L25_SM_STATE_DONE</b></td></tr>
<tr class="separator:ga05b8dae4e35062e4ff079b0bca89480b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacbd3c58cb963cf304091fe1ef27e5e0"><td class="memItemLeft" align="right" valign="top"><a id="gaacbd3c58cb963cf304091fe1ef27e5e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CS40L25_SM_STATE_ERROR</b></td></tr>
<tr class="separator:gaacbd3c58cb963cf304091fe1ef27e5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga183506d8550da09bd9a42025ac3ed889"><td class="memItemLeft" align="right" valign="top"><a id="ga183506d8550da09bd9a42025ac3ed889"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga183506d8550da09bd9a42025ac3ed889">CS40L25_POLL_ACK_CTRL_MS</a></td></tr>
<tr class="memdesc:ga183506d8550da09bd9a42025ac3ed889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay in ms between polling OTP_BOOT_DONE. <br /></td></tr>
<tr class="separator:ga183506d8550da09bd9a42025ac3ed889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae43096ba98a1617bf872ec80948e9c68"><td class="memItemLeft" align="right" valign="top"><a id="gae43096ba98a1617bf872ec80948e9c68"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gae43096ba98a1617bf872ec80948e9c68">CS40L25_POLL_ACK_CTRL_MAX</a></td></tr>
<tr class="memdesc:gae43096ba98a1617bf872ec80948e9c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of times to poll OTP_BOOT_DONE. <br /></td></tr>
<tr class="separator:gae43096ba98a1617bf872ec80948e9c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf3c90874b55835e371b7831a0ca78c7"><td class="memItemLeft" align="right" valign="top"><a id="gacf3c90874b55835e371b7831a0ca78c7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gacf3c90874b55835e371b7831a0ca78c7">CS40L25_POLL_OTP_BOOT_DONE_MS</a></td></tr>
<tr class="memdesc:gacf3c90874b55835e371b7831a0ca78c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay in ms between polling OTP_BOOT_DONE. <br /></td></tr>
<tr class="separator:gacf3c90874b55835e371b7831a0ca78c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae70a3b142e5ed1f9e3da5e7b6e8a738a"><td class="memItemLeft" align="right" valign="top"><a id="gae70a3b142e5ed1f9e3da5e7b6e8a738a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gae70a3b142e5ed1f9e3da5e7b6e8a738a">CS40L25_POLL_OTP_BOOT_DONE_MAX</a></td></tr>
<tr class="memdesc:gae70a3b142e5ed1f9e3da5e7b6e8a738a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of times to poll OTP_BOOT_DONE. <br /></td></tr>
<tr class="separator:gae70a3b142e5ed1f9e3da5e7b6e8a738a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ec46b86af44f2e8b86c29697812750e"><td class="memItemLeft" align="right" valign="top"><a id="ga3ec46b86af44f2e8b86c29697812750e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga3ec46b86af44f2e8b86c29697812750e">CS40L25_OTP_SIZE_WORDS</a></td></tr>
<tr class="memdesc:ga3ec46b86af44f2e8b86c29697812750e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total size of CS40L25 OTP in 32-bit words. <br /></td></tr>
<tr class="separator:ga3ec46b86af44f2e8b86c29697812750e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68aa0df6f64a3d0c1d13ac685704fc0a"><td class="memItemLeft" align="right" valign="top"><a id="ga68aa0df6f64a3d0c1d13ac685704fc0a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga68aa0df6f64a3d0c1d13ac685704fc0a">CS40L25_CP_BULK_READ_LENGTH_BYTES</a></td></tr>
<tr class="memdesc:ga68aa0df6f64a3d0c1d13ac685704fc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of Control Port Bulk Read. <br /></td></tr>
<tr class="separator:ga68aa0df6f64a3d0c1d13ac685704fc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61eeb3a5e5bdc2068f01371cf15dc118"><td class="memItemLeft" align="right" valign="top"><a id="ga61eeb3a5e5bdc2068f01371cf15dc118"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga61eeb3a5e5bdc2068f01371cf15dc118">CS40L25_CP_REG_READ_LENGTH_BYTES</a></td></tr>
<tr class="memdesc:ga61eeb3a5e5bdc2068f01371cf15dc118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of Control Port Read of registers. <br /></td></tr>
<tr class="separator:ga61eeb3a5e5bdc2068f01371cf15dc118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b97233afe3013afc65fdce724145df8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga5b97233afe3013afc65fdce724145df8">CS40L25_CP_READ_BUFFER_LENGTH_BYTES</a></td></tr>
<tr class="memdesc:ga5b97233afe3013afc65fdce724145df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of Control Port Read buffer.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga5b97233afe3013afc65fdce724145df8">More...</a><br /></td></tr>
<tr class="separator:ga5b97233afe3013afc65fdce724145df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf636142b8de71f4a24a729bd9c2c9081"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaf636142b8de71f4a24a729bd9c2c9081">CS40L25_CONTROL_REQUESTS_SIZE</a></td></tr>
<tr class="memdesc:gaf636142b8de71f4a24a729bd9c2c9081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of Control Request Queue.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaf636142b8de71f4a24a729bd9c2c9081">More...</a><br /></td></tr>
<tr class="separator:gaf636142b8de71f4a24a729bd9c2c9081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf109aac045b99206a6c2b5ba98331885"><td class="memItemLeft" align="right" valign="top"><a id="gaf109aac045b99206a6c2b5ba98331885"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaf109aac045b99206a6c2b5ba98331885">CS40L25_CONFIG_REGISTERS_TOTAL</a></td></tr>
<tr class="memdesc:gaf109aac045b99206a6c2b5ba98331885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total registers modified during Configure SM. <br /></td></tr>
<tr class="separator:gaf109aac045b99206a6c2b5ba98331885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e66ef2c5efafed15112d0d7a5b5d1b6"><td class="memItemLeft" align="right" valign="top"><a id="ga6e66ef2c5efafed15112d0d7a5b5d1b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga6e66ef2c5efafed15112d0d7a5b5d1b6">CS40L25_CONFIG_REGISTERS_CODEC</a></td></tr>
<tr class="memdesc:ga6e66ef2c5efafed15112d0d7a5b5d1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total codec registers modified during Configure SM. <br /></td></tr>
<tr class="separator:ga6e66ef2c5efafed15112d0d7a5b5d1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad433915a97ac4b619126f6db424e6a12"><td class="memItemLeft" align="right" valign="top"><a id="gad433915a97ac4b619126f6db424e6a12"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gad433915a97ac4b619126f6db424e6a12">CS40L25_INPUT_SRC_DISABLE</a></td></tr>
<tr class="memdesc:gad433915a97ac4b619126f6db424e6a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data Routing value to indicate 'disabled'. <br /></td></tr>
<tr class="separator:gad433915a97ac4b619126f6db424e6a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c5c966ebfc57fc24acee84e730ead8"><td class="memItemLeft" align="right" valign="top"><a id="ga49c5c966ebfc57fc24acee84e730ead8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DSP_REG</b>(X)</td></tr>
<tr class="separator:ga49c5c966ebfc57fc24acee84e730ead8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bef175dd06efddb80992ccbb7c2ad69"><td class="memItemLeft" align="right" valign="top"><a id="ga5bef175dd06efddb80992ccbb7c2ad69"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga5bef175dd06efddb80992ccbb7c2ad69">CS40L25_DSP_STATUS_WORDS_TOTAL</a></td></tr>
<tr class="memdesc:ga5bef175dd06efddb80992ccbb7c2ad69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total registers to read for Get DSP Status control. <br /></td></tr>
<tr class="separator:ga5bef175dd06efddb80992ccbb7c2ad69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb2150750f34fc8012902e89ffda7e10"><td class="memItemLeft" align="right" valign="top"><a id="gacb2150750f34fc8012902e89ffda7e10"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gacb2150750f34fc8012902e89ffda7e10">debug_printf</a>(...)</td></tr>
<tr class="memdesc:gacb2150750f34fc8012902e89ffda7e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">debug printf safe to use when semihosting is disabled <br /></td></tr>
<tr class="separator:gacb2150750f34fc8012902e89ffda7e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1df91359c5aeccc97d3d33f6f49f41c3"><td class="memItemLeft" align="right" valign="top"><a id="ga1df91359c5aeccc97d3d33f6f49f41c3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CS40L25_MAX_COEFF_FILES</b></td></tr>
<tr class="separator:ga1df91359c5aeccc97d3d33f6f49f41c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga79a15a64c3002ca69a17d65b1df14149"><td class="memItemLeft" align="right" valign="top">typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga79a15a64c3002ca69a17d65b1df14149">cs40l25_sm_fp_t</a>) (void *driver)</td></tr>
<tr class="memdesc:ga79a15a64c3002ca69a17d65b1df14149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to driver control state machine implementation.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga79a15a64c3002ca69a17d65b1df14149">More...</a><br /></td></tr>
<tr class="separator:ga79a15a64c3002ca69a17d65b1df14149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b78156f6addb3f1db4918f59f2ac6c9"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga0b78156f6addb3f1db4918f59f2ac6c9">cs40l25_notification_callback_t</a>) (uint32_t event_flags, void *arg)</td></tr>
<tr class="memdesc:ga0b78156f6addb3f1db4918f59f2ac6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to Notification Callback.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga0b78156f6addb3f1db4918f59f2ac6c9">More...</a><br /></td></tr>
<tr class="separator:ga0b78156f6addb3f1db4918f59f2ac6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44fbc7618e0385fff020c153a1651c71"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga44fbc7618e0385fff020c153a1651c71">cs40l25_control_callback_t</a>) (uint8_t id, uint32_t status, void *arg)</td></tr>
<tr class="memdesc:ga44fbc7618e0385fff020c153a1651c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer to Control Request Callback.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga44fbc7618e0385fff020c153a1651c71">More...</a><br /></td></tr>
<tr class="separator:ga44fbc7618e0385fff020c153a1651c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaf759878ad952ea7b281faa71e34a3143"><td class="memItemLeft" align="right" valign="top"><a id="gaf759878ad952ea7b281faa71e34a3143"></a>
<a class="el" href="structhalo__boot__block__t.html">halo_boot_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaf759878ad952ea7b281faa71e34a3143">cs40l25_halo_boot_file_t::data</a></td></tr>
<tr class="memdesc:gaf759878ad952ea7b281faa71e34a3143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to list of data blocks. <br /></td></tr>
<tr class="separator:gaf759878ad952ea7b281faa71e34a3143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f753f355561e07cc7fbf95a1051d825"><td class="memItemLeft" align="right" valign="top"><a id="ga7f753f355561e07cc7fbf95a1051d825"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga7f753f355561e07cc7fbf95a1051d825">cs40l25_halo_boot_file_t::total_blocks</a></td></tr>
<tr class="memdesc:ga7f753f355561e07cc7fbf95a1051d825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of data blocks in list. <br /></td></tr>
<tr class="separator:ga7f753f355561e07cc7fbf95a1051d825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacb7e7bcab7f7a17a11cc21234cd4f72"><td class="memItemLeft" align="right" valign="top"><a id="gaacb7e7bcab7f7a17a11cc21234cd4f72"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaacb7e7bcab7f7a17a11cc21234cd4f72">cs40l25_boot_config_t::total_fw_blocks</a></td></tr>
<tr class="memdesc:gaacb7e7bcab7f7a17a11cc21234cd4f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total blocks of firmware payload. <br /></td></tr>
<tr class="separator:gaacb7e7bcab7f7a17a11cc21234cd4f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6050a2b7fddbd63f9f02e536b6a665f"><td class="memItemLeft" align="right" valign="top"><a id="gab6050a2b7fddbd63f9f02e536b6a665f"></a>
<a class="el" href="structhalo__boot__block__t.html">halo_boot_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gab6050a2b7fddbd63f9f02e536b6a665f">cs40l25_boot_config_t::fw_blocks</a></td></tr>
<tr class="memdesc:gab6050a2b7fddbd63f9f02e536b6a665f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to list of firmware boot blocks. <br /></td></tr>
<tr class="separator:gab6050a2b7fddbd63f9f02e536b6a665f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdca7b59dcb7a2ebced4afa2b7494185"><td class="memItemLeft" align="right" valign="top"><a id="gacdca7b59dcb7a2ebced4afa2b7494185"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gacdca7b59dcb7a2ebced4afa2b7494185">cs40l25_boot_config_t::total_coeff_blocks</a></td></tr>
<tr class="memdesc:gacdca7b59dcb7a2ebced4afa2b7494185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total blocks of payload of all coeff files. <br /></td></tr>
<tr class="separator:gacdca7b59dcb7a2ebced4afa2b7494185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3cd67106328847b4d200120d72e4317"><td class="memItemLeft" align="right" valign="top"><a id="gad3cd67106328847b4d200120d72e4317"></a>
<a class="el" href="structcs40l25__halo__boot__file__t.html">cs40l25_halo_boot_file_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gad3cd67106328847b4d200120d72e4317">cs40l25_boot_config_t::coeff_files</a> [CS40L25_MAX_COEFF_FILES]</td></tr>
<tr class="memdesc:gad3cd67106328847b4d200120d72e4317"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of coeffiecient boot block list wrappers. <br /></td></tr>
<tr class="separator:gad3cd67106328847b4d200120d72e4317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca50ea95e6e4632228e3080ed34e5c4b"><td class="memItemLeft" align="right" valign="top"><a id="gaca50ea95e6e4632228e3080ed34e5c4b"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaca50ea95e6e4632228e3080ed34e5c4b">cs40l25_boot_config_t::total_cal_blocks</a></td></tr>
<tr class="memdesc:gaca50ea95e6e4632228e3080ed34e5c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total blocks of calibration firmware payload. <br /></td></tr>
<tr class="separator:gaca50ea95e6e4632228e3080ed34e5c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3648ba0d64ed0f26b83b90fb3faca429"><td class="memItemLeft" align="right" valign="top"><a id="ga3648ba0d64ed0f26b83b90fb3faca429"></a>
<a class="el" href="structhalo__boot__block__t.html">halo_boot_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga3648ba0d64ed0f26b83b90fb3faca429">cs40l25_boot_config_t::cal_blocks</a></td></tr>
<tr class="memdesc:ga3648ba0d64ed0f26b83b90fb3faca429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to list of calibration firmware boot blocks. <br /></td></tr>
<tr class="separator:ga3648ba0d64ed0f26b83b90fb3faca429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeda4b439d5bca3b3117b09f88f0e691e"><td class="memItemLeft" align="right" valign="top"><a id="gaeda4b439d5bca3b3117b09f88f0e691e"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaeda4b439d5bca3b3117b09f88f0e691e">cs40l25_sm_t::state</a></td></tr>
<tr class="memdesc:gaeda4b439d5bca3b3117b09f88f0e691e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current state of state machine. <br /></td></tr>
<tr class="separator:gaeda4b439d5bca3b3117b09f88f0e691e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7343ff560ce1becbf38b296158e305"><td class="memItemLeft" align="right" valign="top"><a id="ga8d7343ff560ce1becbf38b296158e305"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga8d7343ff560ce1becbf38b296158e305">cs40l25_sm_t::flags</a></td></tr>
<tr class="memdesc:ga8d7343ff560ce1becbf38b296158e305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current event/notification flags the state machine should process. <br /></td></tr>
<tr class="separator:ga8d7343ff560ce1becbf38b296158e305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242090220b4837d288d92a40918a4d56"><td class="memItemLeft" align="right" valign="top"><a id="ga242090220b4837d288d92a40918a4d56"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga242090220b4837d288d92a40918a4d56">cs40l25_sm_t::count</a></td></tr>
<tr class="memdesc:ga242090220b4837d288d92a40918a4d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter allocated to simplify number of states. <br /></td></tr>
<tr class="separator:ga242090220b4837d288d92a40918a4d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0071fd41241fbb86bcbcfad14b8e094"><td class="memItemLeft" align="right" valign="top"><a id="gae0071fd41241fbb86bcbcfad14b8e094"></a>
<a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga79a15a64c3002ca69a17d65b1df14149">cs40l25_sm_fp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gae0071fd41241fbb86bcbcfad14b8e094">cs40l25_sm_t::fp</a></td></tr>
<tr class="memdesc:gae0071fd41241fbb86bcbcfad14b8e094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to state machine implementation. <br /></td></tr>
<tr class="separator:gae0071fd41241fbb86bcbcfad14b8e094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa842ab60fa9b35c054b4cfb13498a5a2"><td class="memItemLeft" align="right" valign="top"><a id="gaa842ab60fa9b35c054b4cfb13498a5a2"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaa842ab60fa9b35c054b4cfb13498a5a2">cs40l25_control_request_t::id</a></td></tr>
<tr class="memdesc:gaa842ab60fa9b35c054b4cfb13498a5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control ID. <br /></td></tr>
<tr class="separator:gaa842ab60fa9b35c054b4cfb13498a5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac30968451fb8e298d9fa0836af072183"><td class="memItemLeft" align="right" valign="top"><a id="gac30968451fb8e298d9fa0836af072183"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gac30968451fb8e298d9fa0836af072183">cs40l25_control_request_t::arg</a></td></tr>
<tr class="memdesc:gac30968451fb8e298d9fa0836af072183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument for Control Request (nature depends on type of request) <br /></td></tr>
<tr class="separator:gac30968451fb8e298d9fa0836af072183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac55d12464bf1ae5588e6e8d03f756041"><td class="memItemLeft" align="right" valign="top"><a id="gac55d12464bf1ae5588e6e8d03f756041"></a>
<a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga44fbc7618e0385fff020c153a1651c71">cs40l25_control_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gac55d12464bf1ae5588e6e8d03f756041">cs40l25_control_request_t::cb</a></td></tr>
<tr class="memdesc:gac55d12464bf1ae5588e6e8d03f756041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control Request complete callback. <br /></td></tr>
<tr class="separator:gac55d12464bf1ae5588e6e8d03f756041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad711f3dd3bc9de3f2e90e32135298496"><td class="memItemLeft" align="right" valign="top"><a id="gad711f3dd3bc9de3f2e90e32135298496"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gad711f3dd3bc9de3f2e90e32135298496">cs40l25_control_request_t::cb_arg</a></td></tr>
<tr class="memdesc:gad711f3dd3bc9de3f2e90e32135298496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument for Control Request complete callback. <br /></td></tr>
<tr class="separator:gad711f3dd3bc9de3f2e90e32135298496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab96283e90d9b71a34ca87ffcb40bc66c"><td class="memItemLeft" align="right" valign="top"><a id="gab96283e90d9b71a34ca87ffcb40bc66c"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gab96283e90d9b71a34ca87ffcb40bc66c">cs40l25_field_accessor_t::address</a></td></tr>
<tr class="memdesc:gab96283e90d9b71a34ca87ffcb40bc66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control Port address of field to access. <br /></td></tr>
<tr class="separator:gab96283e90d9b71a34ca87ffcb40bc66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79ec325cdaa1e05060cb39d010063613"><td class="memItemLeft" align="right" valign="top"><a id="ga79ec325cdaa1e05060cb39d010063613"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga79ec325cdaa1e05060cb39d010063613">cs40l25_field_accessor_t::value</a></td></tr>
<tr class="memdesc:ga79ec325cdaa1e05060cb39d010063613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value to write/value read. <br /></td></tr>
<tr class="separator:ga79ec325cdaa1e05060cb39d010063613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ce4cfbd9abd23311d12de5e40d0827"><td class="memItemLeft" align="right" valign="top"><a id="ga99ce4cfbd9abd23311d12de5e40d0827"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga99ce4cfbd9abd23311d12de5e40d0827">cs40l25_field_accessor_t::size</a></td></tr>
<tr class="memdesc:ga99ce4cfbd9abd23311d12de5e40d0827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise size of field to access in register. <br /></td></tr>
<tr class="separator:ga99ce4cfbd9abd23311d12de5e40d0827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77db3d5aff675e6354134edac403edec"><td class="memItemLeft" align="right" valign="top"><a id="ga77db3d5aff675e6354134edac403edec"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga77db3d5aff675e6354134edac403edec">cs40l25_field_accessor_t::shift</a></td></tr>
<tr class="memdesc:ga77db3d5aff675e6354134edac403edec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise shift of field to access in register. <br /></td></tr>
<tr class="separator:ga77db3d5aff675e6354134edac403edec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3f2f44e0425f1dea3fcf66a75d860ae"><td class="memItemLeft" align="right" valign="top"><a id="gaf3f2f44e0425f1dea3fcf66a75d860ae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaf3f2f44e0425f1dea3fcf66a75d860ae">cs40l25_field_accessor_t::ack_ctrl</a></td></tr>
<tr class="memdesc:gaf3f2f44e0425f1dea3fcf66a75d860ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">(True) Signal field is an acknowledge control <br /></td></tr>
<tr class="separator:gaf3f2f44e0425f1dea3fcf66a75d860ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga392ea6b5d94569eadf357751e9d1bb44"><td class="memItemLeft" align="right" valign="top"><a id="ga392ea6b5d94569eadf357751e9d1bb44"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga392ea6b5d94569eadf357751e9d1bb44">cs40l25_field_accessor_t::ack_reset</a></td></tr>
<tr class="memdesc:ga392ea6b5d94569eadf357751e9d1bb44"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value the field should reset to on ack (only valid for ack ctrls) <br /></td></tr>
<tr class="separator:ga392ea6b5d94569eadf357751e9d1bb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a4bc47a8d13893a8c0c323848900528"><td class="memItemLeft" align="right" valign="top"><a id="ga3a4bc47a8d13893a8c0c323848900528"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga3a4bc47a8d13893a8c0c323848900528">cs40l25_audio_hw_config_t::is_master_mode</a></td></tr>
<tr class="memdesc:ga3a4bc47a8d13893a8c0c323848900528"><td class="mdescLeft">&#160;</td><td class="mdescRight">(True) Set ASP in Master Mode <br /></td></tr>
<tr class="separator:ga3a4bc47a8d13893a8c0c323848900528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6e6679752056d986892bf08bb75980f"><td class="memItemLeft" align="right" valign="top"><a id="gae6e6679752056d986892bf08bb75980f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gae6e6679752056d986892bf08bb75980f">cs40l25_audio_hw_config_t::fsync_inv</a></td></tr>
<tr class="memdesc:gae6e6679752056d986892bf08bb75980f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(True) Invert polarity of FSYNC <br /></td></tr>
<tr class="separator:gae6e6679752056d986892bf08bb75980f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa189fe29a79e729cb0ba926aa6ef9723"><td class="memItemLeft" align="right" valign="top"><a id="gaa189fe29a79e729cb0ba926aa6ef9723"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaa189fe29a79e729cb0ba926aa6ef9723">cs40l25_audio_hw_config_t::bclk_inv</a></td></tr>
<tr class="memdesc:gaa189fe29a79e729cb0ba926aa6ef9723"><td class="mdescLeft">&#160;</td><td class="mdescRight">(True) Invert polarity of BCLK <br /></td></tr>
<tr class="separator:gaa189fe29a79e729cb0ba926aa6ef9723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabacd7f8aebdd5f45393a89b54ab60a9e"><td class="memItemLeft" align="right" valign="top"><a id="gabacd7f8aebdd5f45393a89b54ab60a9e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gabacd7f8aebdd5f45393a89b54ab60a9e">cs40l25_audio_hw_config_t::amp_dre_en</a></td></tr>
<tr class="memdesc:gabacd7f8aebdd5f45393a89b54ab60a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(True) Enable Amplifier DRE <br /></td></tr>
<tr class="separator:gabacd7f8aebdd5f45393a89b54ab60a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37671285e5cc316267413f2136d58041"><td class="memItemLeft" align="right" valign="top"><a id="ga37671285e5cc316267413f2136d58041"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga37671285e5cc316267413f2136d58041">cs40l25_audio_hw_config_t::ng_enable</a></td></tr>
<tr class="memdesc:ga37671285e5cc316267413f2136d58041"><td class="mdescLeft">&#160;</td><td class="mdescRight">(True) Enable Noise Gate <br /></td></tr>
<tr class="separator:ga37671285e5cc316267413f2136d58041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c7fcca5dc7a65445d40b331047e5e49"><td class="memItemLeft" align="right" valign="top"><a id="ga5c7fcca5dc7a65445d40b331047e5e49"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga5c7fcca5dc7a65445d40b331047e5e49">cs40l25_audio_hw_config_t::ng_thld</a></td></tr>
<tr class="memdesc:ga5c7fcca5dc7a65445d40b331047e5e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Noise Gate threshold. See datasheet Section 7.19.3. <br /></td></tr>
<tr class="separator:ga5c7fcca5dc7a65445d40b331047e5e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00eda1c26e0dbc2062ce7e18de6f7554"><td class="memItemLeft" align="right" valign="top"><a id="ga00eda1c26e0dbc2062ce7e18de6f7554"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga00eda1c26e0dbc2062ce7e18de6f7554">cs40l25_audio_hw_config_t::ng_delay</a></td></tr>
<tr class="memdesc:ga00eda1c26e0dbc2062ce7e18de6f7554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Noise Gate delay. See datasheet Section 7.19.3. <br /></td></tr>
<tr class="separator:ga00eda1c26e0dbc2062ce7e18de6f7554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab858dc315c402c0ea2da274c61c264db"><td class="memItemLeft" align="right" valign="top"><a id="gab858dc315c402c0ea2da274c61c264db"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gab858dc315c402c0ea2da274c61c264db">cs40l25_audio_hw_config_t::amp_ramp_pcm</a></td></tr>
<tr class="memdesc:gab858dc315c402c0ea2da274c61c264db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amplifier PCM audio digital soft-ramp rate. See datasheet Section 7.17.1. <br /></td></tr>
<tr class="separator:gab858dc315c402c0ea2da274c61c264db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga335d0df498c39cf2834e5107f2259979"><td class="memItemLeft" align="right" valign="top"><a id="ga335d0df498c39cf2834e5107f2259979"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga335d0df498c39cf2834e5107f2259979">cs40l25_asp_config_t::is_i2s</a></td></tr>
<tr class="memdesc:ga335d0df498c39cf2834e5107f2259979"><td class="mdescLeft">&#160;</td><td class="mdescRight">(True) Port is in I2S mode; (False) Port is in DSPA mode <br /></td></tr>
<tr class="separator:ga335d0df498c39cf2834e5107f2259979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75d61677ce7e8c9242b6a3f0f6ef27e6"><td class="memItemLeft" align="right" valign="top"><a id="ga75d61677ce7e8c9242b6a3f0f6ef27e6"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga75d61677ce7e8c9242b6a3f0f6ef27e6">cs40l25_asp_config_t::rx1_slot</a></td></tr>
<tr class="memdesc:ga75d61677ce7e8c9242b6a3f0f6ef27e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slot position for RX Channel 1. <br /></td></tr>
<tr class="separator:ga75d61677ce7e8c9242b6a3f0f6ef27e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga255aea0ca8ecb7db04fd47bd6d176e27"><td class="memItemLeft" align="right" valign="top"><a id="ga255aea0ca8ecb7db04fd47bd6d176e27"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga255aea0ca8ecb7db04fd47bd6d176e27">cs40l25_asp_config_t::rx2_slot</a></td></tr>
<tr class="memdesc:ga255aea0ca8ecb7db04fd47bd6d176e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slot position for RX Channel 2. <br /></td></tr>
<tr class="separator:ga255aea0ca8ecb7db04fd47bd6d176e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9d7645bb22d8c16fdc135e3072cb48"><td class="memItemLeft" align="right" valign="top"><a id="ga0d9d7645bb22d8c16fdc135e3072cb48"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga0d9d7645bb22d8c16fdc135e3072cb48">cs40l25_asp_config_t::tx1_slot</a></td></tr>
<tr class="memdesc:ga0d9d7645bb22d8c16fdc135e3072cb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slot position for TX Channel 1. <br /></td></tr>
<tr class="separator:ga0d9d7645bb22d8c16fdc135e3072cb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a9ac2b70f1441eb0b5f6f7756554fbb"><td class="memItemLeft" align="right" valign="top"><a id="ga1a9ac2b70f1441eb0b5f6f7756554fbb"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga1a9ac2b70f1441eb0b5f6f7756554fbb">cs40l25_asp_config_t::tx2_slot</a></td></tr>
<tr class="memdesc:ga1a9ac2b70f1441eb0b5f6f7756554fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slot position for TX Channel 2. <br /></td></tr>
<tr class="separator:ga1a9ac2b70f1441eb0b5f6f7756554fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a33420e4e83e3f231a6f7ed4c7eaba6"><td class="memItemLeft" align="right" valign="top"><a id="ga5a33420e4e83e3f231a6f7ed4c7eaba6"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga5a33420e4e83e3f231a6f7ed4c7eaba6">cs40l25_asp_config_t::tx3_slot</a></td></tr>
<tr class="memdesc:ga5a33420e4e83e3f231a6f7ed4c7eaba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slot position for TX Channel 3. <br /></td></tr>
<tr class="separator:ga5a33420e4e83e3f231a6f7ed4c7eaba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9dd15e791a8f18ab0750084d7a8ba61"><td class="memItemLeft" align="right" valign="top"><a id="gae9dd15e791a8f18ab0750084d7a8ba61"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gae9dd15e791a8f18ab0750084d7a8ba61">cs40l25_asp_config_t::tx4_slot</a></td></tr>
<tr class="memdesc:gae9dd15e791a8f18ab0750084d7a8ba61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slot position for TX Channel 4. <br /></td></tr>
<tr class="separator:gae9dd15e791a8f18ab0750084d7a8ba61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a54e46932771e0cacd941bf5d82f36b"><td class="memItemLeft" align="right" valign="top"><a id="ga7a54e46932771e0cacd941bf5d82f36b"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga7a54e46932771e0cacd941bf5d82f36b">cs40l25_asp_config_t::tx_wl</a></td></tr>
<tr class="memdesc:ga7a54e46932771e0cacd941bf5d82f36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">TX active data width (in number of BCLK cycles) <br /></td></tr>
<tr class="separator:ga7a54e46932771e0cacd941bf5d82f36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga209c66dab2def4816f3aab81364cc04a"><td class="memItemLeft" align="right" valign="top"><a id="ga209c66dab2def4816f3aab81364cc04a"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga209c66dab2def4816f3aab81364cc04a">cs40l25_asp_config_t::tx_width</a></td></tr>
<tr class="memdesc:ga209c66dab2def4816f3aab81364cc04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">TX slot width (in number of BCLK cycles) <br /></td></tr>
<tr class="separator:ga209c66dab2def4816f3aab81364cc04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f732c9f2d65b0c155901b9d7275ae0"><td class="memItemLeft" align="right" valign="top"><a id="ga88f732c9f2d65b0c155901b9d7275ae0"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga88f732c9f2d65b0c155901b9d7275ae0">cs40l25_asp_config_t::rx_wl</a></td></tr>
<tr class="memdesc:ga88f732c9f2d65b0c155901b9d7275ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">RX active data width (in number of BCLK cycles) <br /></td></tr>
<tr class="separator:ga88f732c9f2d65b0c155901b9d7275ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77a4f05e12c57152aee4b3b66fdca8e5"><td class="memItemLeft" align="right" valign="top"><a id="ga77a4f05e12c57152aee4b3b66fdca8e5"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga77a4f05e12c57152aee4b3b66fdca8e5">cs40l25_asp_config_t::rx_width</a></td></tr>
<tr class="memdesc:ga77a4f05e12c57152aee4b3b66fdca8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">RX slot width (in number of BCLK cycles) <br /></td></tr>
<tr class="separator:ga77a4f05e12c57152aee4b3b66fdca8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafca0e6543132cb7e4716383e27812068"><td class="memItemLeft" align="right" valign="top"><a id="gafca0e6543132cb7e4716383e27812068"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gafca0e6543132cb7e4716383e27812068">cs40l25_routing_config_t::dac_src</a></td></tr>
<tr class="memdesc:gafca0e6543132cb7e4716383e27812068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amplifier DAC audio mixer source. <br /></td></tr>
<tr class="separator:gafca0e6543132cb7e4716383e27812068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffde9d25448bec9480d3360ab6d291c5"><td class="memItemLeft" align="right" valign="top"><a id="gaffde9d25448bec9480d3360ab6d291c5"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaffde9d25448bec9480d3360ab6d291c5">cs40l25_routing_config_t::dsp_rx1_src</a></td></tr>
<tr class="memdesc:gaffde9d25448bec9480d3360ab6d291c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">DSP RX Channel 1 audio mixer source. <br /></td></tr>
<tr class="separator:gaffde9d25448bec9480d3360ab6d291c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ace380e5da5eb6538224f809bd4b520"><td class="memItemLeft" align="right" valign="top"><a id="ga9ace380e5da5eb6538224f809bd4b520"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga9ace380e5da5eb6538224f809bd4b520">cs40l25_routing_config_t::dsp_rx2_src</a></td></tr>
<tr class="memdesc:ga9ace380e5da5eb6538224f809bd4b520"><td class="mdescLeft">&#160;</td><td class="mdescRight">DSP RX Channel 2 audio mixer source. <br /></td></tr>
<tr class="separator:ga9ace380e5da5eb6538224f809bd4b520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf184f50b36b38ce3f2acb45e423d905f"><td class="memItemLeft" align="right" valign="top"><a id="gaf184f50b36b38ce3f2acb45e423d905f"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaf184f50b36b38ce3f2acb45e423d905f">cs40l25_routing_config_t::dsp_rx3_src</a></td></tr>
<tr class="memdesc:gaf184f50b36b38ce3f2acb45e423d905f"><td class="mdescLeft">&#160;</td><td class="mdescRight">DSP RX Channel 3 audio mixer source. <br /></td></tr>
<tr class="separator:gaf184f50b36b38ce3f2acb45e423d905f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62d143640897d014b7473cd305622d48"><td class="memItemLeft" align="right" valign="top"><a id="ga62d143640897d014b7473cd305622d48"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga62d143640897d014b7473cd305622d48">cs40l25_routing_config_t::dsp_rx4_src</a></td></tr>
<tr class="memdesc:ga62d143640897d014b7473cd305622d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">DSP RX Channel 4 audio mixer source. <br /></td></tr>
<tr class="separator:ga62d143640897d014b7473cd305622d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe03ee72be05350f051facf20551805"><td class="memItemLeft" align="right" valign="top"><a id="ga1fe03ee72be05350f051facf20551805"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga1fe03ee72be05350f051facf20551805">cs40l25_routing_config_t::asp_tx1_src</a></td></tr>
<tr class="memdesc:ga1fe03ee72be05350f051facf20551805"><td class="mdescLeft">&#160;</td><td class="mdescRight">ASP TX Channel 1 audio mixer source. <br /></td></tr>
<tr class="separator:ga1fe03ee72be05350f051facf20551805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45955ac7a415a5248da9d5f1afee20cf"><td class="memItemLeft" align="right" valign="top"><a id="ga45955ac7a415a5248da9d5f1afee20cf"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga45955ac7a415a5248da9d5f1afee20cf">cs40l25_routing_config_t::asp_tx2_src</a></td></tr>
<tr class="memdesc:ga45955ac7a415a5248da9d5f1afee20cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">ASP TX Channel 2 audio mixer source. <br /></td></tr>
<tr class="separator:ga45955ac7a415a5248da9d5f1afee20cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e63a2f601e125c630b9cec9ad2e5b2c"><td class="memItemLeft" align="right" valign="top"><a id="ga8e63a2f601e125c630b9cec9ad2e5b2c"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga8e63a2f601e125c630b9cec9ad2e5b2c">cs40l25_routing_config_t::asp_tx3_src</a></td></tr>
<tr class="memdesc:ga8e63a2f601e125c630b9cec9ad2e5b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ASP TX Channel 3 audio mixer source. <br /></td></tr>
<tr class="separator:ga8e63a2f601e125c630b9cec9ad2e5b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41edd20734120bdb38471353372491aa"><td class="memItemLeft" align="right" valign="top"><a id="ga41edd20734120bdb38471353372491aa"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga41edd20734120bdb38471353372491aa">cs40l25_routing_config_t::asp_tx4_src</a></td></tr>
<tr class="memdesc:ga41edd20734120bdb38471353372491aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">ASP TX Channel 4 audio mixer source. <br /></td></tr>
<tr class="separator:ga41edd20734120bdb38471353372491aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1ce5121caea077804edf4c2d6a8faa1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gac1ce5121caea077804edf4c2d6a8faa1">cs40l25_clock_config_t::refclk_sel</a></td></tr>
<tr class="memdesc:gac1ce5121caea077804edf4c2d6a8faa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock source for REFCLK.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gac1ce5121caea077804edf4c2d6a8faa1">More...</a><br /></td></tr>
<tr class="separator:gac1ce5121caea077804edf4c2d6a8faa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ff44c8019dffe43ebf2bccb2e2fa14"><td class="memItemLeft" align="right" valign="top"><a id="ga26ff44c8019dffe43ebf2bccb2e2fa14"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga26ff44c8019dffe43ebf2bccb2e2fa14">cs40l25_clock_config_t::sclk</a></td></tr>
<tr class="memdesc:ga26ff44c8019dffe43ebf2bccb2e2fa14"><td class="mdescLeft">&#160;</td><td class="mdescRight">BCLK (or SCLK) frequency in Hz. <br /></td></tr>
<tr class="separator:ga26ff44c8019dffe43ebf2bccb2e2fa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b12f053f1d20146de7c161cf48a382a"><td class="memItemLeft" align="right" valign="top"><a id="ga3b12f053f1d20146de7c161cf48a382a"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga3b12f053f1d20146de7c161cf48a382a">cs40l25_clock_config_t::refclk_freq</a></td></tr>
<tr class="memdesc:ga3b12f053f1d20146de7c161cf48a382a"><td class="mdescLeft">&#160;</td><td class="mdescRight">REFCLK frequency in Hz. <br /></td></tr>
<tr class="separator:ga3b12f053f1d20146de7c161cf48a382a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga584bca5724799be18ff9546b618499cc"><td class="memItemLeft" align="right" valign="top"><a id="ga584bca5724799be18ff9546b618499cc"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga584bca5724799be18ff9546b618499cc">cs40l25_clock_config_t::global_fs</a></td></tr>
<tr class="memdesc:ga584bca5724799be18ff9546b618499cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">FSYNC frequency in Hz. <br /></td></tr>
<tr class="separator:ga584bca5724799be18ff9546b618499cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6413eff33640bd54fa0168a0818f083"><td class="memItemLeft" align="right" valign="top"><a id="gad6413eff33640bd54fa0168a0818f083"></a>
<a class="el" href="structcs40l25__audio__hw__config__t.html">cs40l25_audio_hw_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_audio_config_t::hw</b></td></tr>
<tr class="separator:gad6413eff33640bd54fa0168a0818f083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc4fc056d8bd5c2c09a4da52de78819b"><td class="memItemLeft" align="right" valign="top"><a id="gacc4fc056d8bd5c2c09a4da52de78819b"></a>
<a class="el" href="structcs40l25__asp__config__t.html">cs40l25_asp_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_audio_config_t::asp</b></td></tr>
<tr class="separator:gacc4fc056d8bd5c2c09a4da52de78819b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga781a9da3fb8f84b875403db7eebf9c95"><td class="memItemLeft" align="right" valign="top"><a id="ga781a9da3fb8f84b875403db7eebf9c95"></a>
<a class="el" href="structcs40l25__routing__config__t.html">cs40l25_routing_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_audio_config_t::routing</b></td></tr>
<tr class="separator:ga781a9da3fb8f84b875403db7eebf9c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9062321e35068be52f31cc8e94551343"><td class="memItemLeft" align="right" valign="top"><a id="ga9062321e35068be52f31cc8e94551343"></a>
<a class="el" href="structcs40l25__clock__config__t.html">cs40l25_clock_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_audio_config_t::clock</b></td></tr>
<tr class="separator:ga9062321e35068be52f31cc8e94551343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf28be3eeb1abf34ebf7563116b1dff3"><td class="memItemLeft" align="right" valign="top"><a id="gabf28be3eeb1abf34ebf7563116b1dff3"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gabf28be3eeb1abf34ebf7563116b1dff3">cs40l25_audio_config_t::volume</a></td></tr>
<tr class="memdesc:gabf28be3eeb1abf34ebf7563116b1dff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume to be applied at reset. <br /></td></tr>
<tr class="separator:gabf28be3eeb1abf34ebf7563116b1dff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1f2e1d2c49e9e4c82520b6ec74724e8"><td class="memItemLeft" align="right" valign="top"><a id="gaa1f2e1d2c49e9e4c82520b6ec74724e8"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaa1f2e1d2c49e9e4c82520b6ec74724e8">cs40l25_amp_config_t::boost_inductor_value_nh</a></td></tr>
<tr class="memdesc:gaa1f2e1d2c49e9e4c82520b6ec74724e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost inductor value in nH. <br /></td></tr>
<tr class="separator:gaa1f2e1d2c49e9e4c82520b6ec74724e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga350be8b7f5048c100e8ef23c8b409c62"><td class="memItemLeft" align="right" valign="top"><a id="ga350be8b7f5048c100e8ef23c8b409c62"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga350be8b7f5048c100e8ef23c8b409c62">cs40l25_amp_config_t::boost_capacitor_value_uf</a></td></tr>
<tr class="memdesc:ga350be8b7f5048c100e8ef23c8b409c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost capacitor value in uF. <br /></td></tr>
<tr class="separator:ga350be8b7f5048c100e8ef23c8b409c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665a6d677b6e93b0aa9d8cc6c4cc3cd5"><td class="memItemLeft" align="right" valign="top"><a id="ga665a6d677b6e93b0aa9d8cc6c4cc3cd5"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga665a6d677b6e93b0aa9d8cc6c4cc3cd5">cs40l25_amp_config_t::boost_ipeak_ma</a></td></tr>
<tr class="memdesc:ga665a6d677b6e93b0aa9d8cc6c4cc3cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost peak current in mA. <br /></td></tr>
<tr class="separator:ga665a6d677b6e93b0aa9d8cc6c4cc3cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga149127679c5d38b5739a61f764d6f453"><td class="memItemLeft" align="right" valign="top"><a id="ga149127679c5d38b5739a61f764d6f453"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga149127679c5d38b5739a61f764d6f453">cs40l25_amp_config_t::bst_ctl</a></td></tr>
<tr class="memdesc:ga149127679c5d38b5739a61f764d6f453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost converter target voltage. See datasheet Section 7.11.1. <br /></td></tr>
<tr class="separator:ga149127679c5d38b5739a61f764d6f453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d7aa3de26481e24c0e664d6d5949a68"><td class="memItemLeft" align="right" valign="top"><a id="ga5d7aa3de26481e24c0e664d6d5949a68"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga5d7aa3de26481e24c0e664d6d5949a68">cs40l25_amp_config_t::classh_enable</a></td></tr>
<tr class="memdesc:ga5d7aa3de26481e24c0e664d6d5949a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">(True) Enable Class H functionality <br /></td></tr>
<tr class="separator:ga5d7aa3de26481e24c0e664d6d5949a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f0d3e60c62f2e6d2b8a493cad73605"><td class="memItemLeft" align="right" valign="top"><a id="ga02f0d3e60c62f2e6d2b8a493cad73605"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga02f0d3e60c62f2e6d2b8a493cad73605">cs40l25_amp_config_t::bst_ctl_sel</a></td></tr>
<tr class="memdesc:ga02f0d3e60c62f2e6d2b8a493cad73605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost converter control source selection. See datasheet Section 7.11.2. <br /></td></tr>
<tr class="separator:ga02f0d3e60c62f2e6d2b8a493cad73605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga337cc72f5c98435634d43b6c3fe33275"><td class="memItemLeft" align="right" valign="top"><a id="ga337cc72f5c98435634d43b6c3fe33275"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga337cc72f5c98435634d43b6c3fe33275">cs40l25_amp_config_t::bst_ctl_lim_en</a></td></tr>
<tr class="memdesc:ga337cc72f5c98435634d43b6c3fe33275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class H boost control max limit. See datasheet Section 7.11.2. <br /></td></tr>
<tr class="separator:ga337cc72f5c98435634d43b6c3fe33275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eca8a4bce08fd693251093e7a019339"><td class="memItemLeft" align="right" valign="top"><a id="ga0eca8a4bce08fd693251093e7a019339"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_config_registers_t::words</b> [<a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaf109aac045b99206a6c2b5ba98331885">CS40L25_CONFIG_REGISTERS_TOTAL</a>]</td></tr>
<tr class="separator:ga0eca8a4bce08fd693251093e7a019339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf9c76ddf4832472796e304e101d67ce"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__intp__amp__ctrl__t.html">cs40l25_intp_amp_ctrl_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::intp_amp_ctrl</b></td></tr>
<tr class="separator:gadf9c76ddf4832472796e304e101d67ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad008c82f1012369eb25273fbe1e90400"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::asptx1_input</b></td></tr>
<tr class="separator:gad008c82f1012369eb25273fbe1e90400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11efc4c1208593819d4b4fbb686c7cbc"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::asptx2_input</b></td></tr>
<tr class="separator:ga11efc4c1208593819d4b4fbb686c7cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0761e966a55d5a65ede7be3d06365fba"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::asptx3_input</b></td></tr>
<tr class="separator:ga0761e966a55d5a65ede7be3d06365fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa898131fa47fb4d6748be38545aef931"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::asptx4_input</b></td></tr>
<tr class="separator:gaa898131fa47fb4d6748be38545aef931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d42c66bdb162131728c20c7b56809d"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dsp1rx1_input</b></td></tr>
<tr class="separator:gae2d42c66bdb162131728c20c7b56809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad59ac69f43ccc11f6d463037d9f6d289"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dsp1rx2_input</b></td></tr>
<tr class="separator:gad59ac69f43ccc11f6d463037d9f6d289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga142a658c4b1c88b6f28c5554c760149b"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dsp1rx3_input</b></td></tr>
<tr class="separator:ga142a658c4b1c88b6f28c5554c760149b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00284430a176be4539eb204f37b1966c"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dsp1rx4_input</b></td></tr>
<tr class="separator:ga00284430a176be4539eb204f37b1966c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga907e907b3a81d7751f46fcb105e50849"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dacpcm1_input</b></td></tr>
<tr class="separator:ga907e907b3a81d7751f46fcb105e50849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9604fb6d0ed7be579473d90d5850ed8c"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__ccm__refclk__input__t.html">cs40l25_ccm_refclk_input_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::ccm_refclk_input</b></td></tr>
<tr class="separator:ga9604fb6d0ed7be579473d90d5850ed8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb902c549592d4b65dcdf1143a203215"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__msm__block__enables__t.html">cs40l25_msm_block_enables_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::msm_block_enables</b></td></tr>
<tr class="separator:gafb902c549592d4b65dcdf1143a203215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc326bcddba1233bc6926dd0552682ea"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__msm__block__enables2__t.html">cs40l25_msm_block_enables2_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::msm_block_enables2</b></td></tr>
<tr class="separator:gacc326bcddba1233bc6926dd0552682ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04950c45975b1bfba62fee1751c8e0a4"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__dataif__asp__enables1__t.html">cs40l25_dataif_asp_enables1_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dataif_asp_enables1</b></td></tr>
<tr class="separator:ga04950c45975b1bfba62fee1751c8e0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f7be4f946ae3390dd4a03a505b5dd06"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__dataif__asp__control2__t.html">cs40l25_dataif_asp_control2_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dataif_asp_control2</b></td></tr>
<tr class="separator:ga5f7be4f946ae3390dd4a03a505b5dd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7b58e319cc5b554c8d0cb9876dd63bf"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__dataif__asp__frame__control5__t.html">cs40l25_dataif_asp_frame_control5_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dataif_asp_frame_control5</b></td></tr>
<tr class="separator:gab7b58e319cc5b554c8d0cb9876dd63bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0be90a3932404fed92653828a45ba68"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__dataif__asp__frame__control1__t.html">cs40l25_dataif_asp_frame_control1_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dataif_asp_frame_control1</b></td></tr>
<tr class="separator:gaa0be90a3932404fed92653828a45ba68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6783bd03781fd5a10e1a37a99cb6795c"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__dataif__asp__data__control5__t.html">cs40l25_dataif_asp_data_control5_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dataif_asp_data_control5</b></td></tr>
<tr class="separator:ga6783bd03781fd5a10e1a37a99cb6795c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6046801af62e2507955d26edc657f0f2"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__dataif__asp__data__control1__t.html">cs40l25_dataif_asp_data_control1_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dataif_asp_data_control1</b></td></tr>
<tr class="separator:ga6046801af62e2507955d26edc657f0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef6fa6a8707d61cc61d629fdbb271b99"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_config_registers_t::ccm_fs_mon0</b></td></tr>
<tr class="separator:gaef6fa6a8707d61cc61d629fdbb271b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacae458dadebdfe1e776c6bcc2a5aa91d"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__dataif__asp__control1__t.html">cs40l25_dataif_asp_control1_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dataif_asp_control1</b></td></tr>
<tr class="separator:gacae458dadebdfe1e776c6bcc2a5aa91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga569b8b0339e96b41301e1a3305653df8"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__boost__lbst__slope__t.html">cs40l25_boost_lbst_slope_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::boost_lbst_slope</b></td></tr>
<tr class="separator:ga569b8b0339e96b41301e1a3305653df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bffe8fe88e2323fbe03fce58cd86e41"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__boost__bst__loop__coeff__t.html">cs40l25_boost_bst_loop_coeff_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::boost_bst_loop_coeff</b></td></tr>
<tr class="separator:ga2bffe8fe88e2323fbe03fce58cd86e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f705055d41621ba702f6826260782e8"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__boost__bst__ipk__ctl__t.html">cs40l25_boost_bst_ipk_ctl_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::boost_bst_ipk_ctl</b></td></tr>
<tr class="separator:ga0f705055d41621ba702f6826260782e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dad077e6a0b4d0aa1bbc0a759618a20"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__boost__vbst__ctl__1__t.html">cs40l25_boost_vbst_ctl_1_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::boost_vbst_ctl_1</b></td></tr>
<tr class="separator:ga1dad077e6a0b4d0aa1bbc0a759618a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d89c770d6cf2612ef29d871bc9f4107"><td class="memItemLeft" >
<a class="el" href="unioncs40l25__boost__vbst__ctl__2__t.html">cs40l25_boost_vbst_ctl_2_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::boost_vbst_ctl_2</b></td></tr>
<tr class="separator:ga1d89c770d6cf2612ef29d871bc9f4107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9aad53e202a6bee412069a802480f4"><td class="memItemLeft" >
<a class="el" href="uniondsp__gpio__button__detect__reg__t.html">dsp_gpio_button_detect_reg_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dsp_gpio_button_detect</b></td></tr>
<tr class="separator:gaec9aad53e202a6bee412069a802480f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c2e905d2e510d21bfe998a54ddaa666"><td class="memItemLeft" >
<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dsp_gpio_enable</b></td></tr>
<tr class="separator:ga1c2e905d2e510d21bfe998a54ddaa666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga801c70b75547976af4ea571656bce9dc"><td class="memItemLeft" >
<a class="el" href="uniondsp__gain__control__reg__t.html">dsp_gain_control_reg_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dsp_gain_control</b></td></tr>
<tr class="separator:ga801c70b75547976af4ea571656bce9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03ac911a9909cb327a1acc320bb5b09a"><td class="memItemLeft" >
<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dsp_gpio1_index_button_press</b></td></tr>
<tr class="separator:ga03ac911a9909cb327a1acc320bb5b09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04f0fafa81a6c73f940cf1839a0a2d89"><td class="memItemLeft" >
<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dsp_gpio2_index_button_press</b></td></tr>
<tr class="separator:ga04f0fafa81a6c73f940cf1839a0a2d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad87548519282af6a4a004aad9b243653"><td class="memItemLeft" >
<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dsp_gpio3_index_button_press</b></td></tr>
<tr class="separator:gad87548519282af6a4a004aad9b243653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6449f08b344974324917efac365c46fc"><td class="memItemLeft" >
<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dsp_gpio4_index_button_press</b></td></tr>
<tr class="separator:ga6449f08b344974324917efac365c46fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9efc6ca49433b9d12fa13593a1b28b2f"><td class="memItemLeft" >
<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dsp_gpio1_index_button_release</b></td></tr>
<tr class="separator:ga9efc6ca49433b9d12fa13593a1b28b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b20f1a3eb617ca06b24e89c3762e42c"><td class="memItemLeft" >
<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dsp_gpio2_index_button_release</b></td></tr>
<tr class="separator:ga2b20f1a3eb617ca06b24e89c3762e42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab86253b6d346a0efa2b2b03252f33c8"><td class="memItemLeft" >
<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dsp_gpio3_index_button_release</b></td></tr>
<tr class="separator:gaab86253b6d346a0efa2b2b03252f33c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd23b20a3b66a0cbf18e01d2cc02cc5"><td class="memItemLeft" >
<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::dsp_gpio4_index_button_release</b></td></tr>
<tr class="separator:ga2bd23b20a3b66a0cbf18e01d2cc02cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f37c2fc78fc5e102955806ca3bbd0ca"><td class="memItemLeft" >
<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::clab_enabled</b></td></tr>
<tr class="separator:ga1f37c2fc78fc5e102955806ca3bbd0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8445bd7eda58a9a55e91952184367d2f"><td class="memItemLeft" >
<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>cs40l25_config_registers_t::peak_amplitude_control</b></td></tr>
<tr class="separator:ga8445bd7eda58a9a55e91952184367d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga171783706fb078addac4177e85a7801d"><td class="memItemLeft" ><a id="ga171783706fb078addac4177e85a7801d"></a>
struct {</td></tr>
<tr class="memitem:gadf9c76ddf4832472796e304e101d67ce"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__intp__amp__ctrl__t.html">cs40l25_intp_amp_ctrl_t</a>&#160;&#160;&#160;<b>intp_amp_ctrl</b></td></tr>
<tr class="separator:gadf9c76ddf4832472796e304e101d67ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad008c82f1012369eb25273fbe1e90400"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>asptx1_input</b></td></tr>
<tr class="separator:gad008c82f1012369eb25273fbe1e90400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11efc4c1208593819d4b4fbb686c7cbc"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>asptx2_input</b></td></tr>
<tr class="separator:ga11efc4c1208593819d4b4fbb686c7cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0761e966a55d5a65ede7be3d06365fba"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>asptx3_input</b></td></tr>
<tr class="separator:ga0761e966a55d5a65ede7be3d06365fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa898131fa47fb4d6748be38545aef931"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>asptx4_input</b></td></tr>
<tr class="separator:gaa898131fa47fb4d6748be38545aef931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d42c66bdb162131728c20c7b56809d"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>dsp1rx1_input</b></td></tr>
<tr class="separator:gae2d42c66bdb162131728c20c7b56809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad59ac69f43ccc11f6d463037d9f6d289"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>dsp1rx2_input</b></td></tr>
<tr class="separator:gad59ac69f43ccc11f6d463037d9f6d289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga142a658c4b1c88b6f28c5554c760149b"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>dsp1rx3_input</b></td></tr>
<tr class="separator:ga142a658c4b1c88b6f28c5554c760149b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00284430a176be4539eb204f37b1966c"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>dsp1rx4_input</b></td></tr>
<tr class="separator:ga00284430a176be4539eb204f37b1966c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga907e907b3a81d7751f46fcb105e50849"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__mixer__t.html">cs40l25_mixer_t</a>&#160;&#160;&#160;<b>dacpcm1_input</b></td></tr>
<tr class="separator:ga907e907b3a81d7751f46fcb105e50849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9604fb6d0ed7be579473d90d5850ed8c"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__ccm__refclk__input__t.html">cs40l25_ccm_refclk_input_t</a>&#160;&#160;&#160;<b>ccm_refclk_input</b></td></tr>
<tr class="separator:ga9604fb6d0ed7be579473d90d5850ed8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb902c549592d4b65dcdf1143a203215"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__msm__block__enables__t.html">cs40l25_msm_block_enables_t</a>&#160;&#160;&#160;<b>msm_block_enables</b></td></tr>
<tr class="separator:gafb902c549592d4b65dcdf1143a203215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc326bcddba1233bc6926dd0552682ea"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__msm__block__enables2__t.html">cs40l25_msm_block_enables2_t</a>&#160;&#160;&#160;<b>msm_block_enables2</b></td></tr>
<tr class="separator:gacc326bcddba1233bc6926dd0552682ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04950c45975b1bfba62fee1751c8e0a4"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__dataif__asp__enables1__t.html">cs40l25_dataif_asp_enables1_t</a>&#160;&#160;&#160;<b>dataif_asp_enables1</b></td></tr>
<tr class="separator:ga04950c45975b1bfba62fee1751c8e0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f7be4f946ae3390dd4a03a505b5dd06"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__dataif__asp__control2__t.html">cs40l25_dataif_asp_control2_t</a>&#160;&#160;&#160;<b>dataif_asp_control2</b></td></tr>
<tr class="separator:ga5f7be4f946ae3390dd4a03a505b5dd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7b58e319cc5b554c8d0cb9876dd63bf"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__dataif__asp__frame__control5__t.html">cs40l25_dataif_asp_frame_control5_t</a>&#160;&#160;&#160;<b>dataif_asp_frame_control5</b></td></tr>
<tr class="separator:gab7b58e319cc5b554c8d0cb9876dd63bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0be90a3932404fed92653828a45ba68"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__dataif__asp__frame__control1__t.html">cs40l25_dataif_asp_frame_control1_t</a>&#160;&#160;&#160;<b>dataif_asp_frame_control1</b></td></tr>
<tr class="separator:gaa0be90a3932404fed92653828a45ba68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6783bd03781fd5a10e1a37a99cb6795c"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__dataif__asp__data__control5__t.html">cs40l25_dataif_asp_data_control5_t</a>&#160;&#160;&#160;<b>dataif_asp_data_control5</b></td></tr>
<tr class="separator:ga6783bd03781fd5a10e1a37a99cb6795c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6046801af62e2507955d26edc657f0f2"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__dataif__asp__data__control1__t.html">cs40l25_dataif_asp_data_control1_t</a>&#160;&#160;&#160;<b>dataif_asp_data_control1</b></td></tr>
<tr class="separator:ga6046801af62e2507955d26edc657f0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef6fa6a8707d61cc61d629fdbb271b99"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>ccm_fs_mon0</b></td></tr>
<tr class="separator:gaef6fa6a8707d61cc61d629fdbb271b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacae458dadebdfe1e776c6bcc2a5aa91d"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__dataif__asp__control1__t.html">cs40l25_dataif_asp_control1_t</a>&#160;&#160;&#160;<b>dataif_asp_control1</b></td></tr>
<tr class="separator:gacae458dadebdfe1e776c6bcc2a5aa91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga569b8b0339e96b41301e1a3305653df8"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__boost__lbst__slope__t.html">cs40l25_boost_lbst_slope_t</a>&#160;&#160;&#160;<b>boost_lbst_slope</b></td></tr>
<tr class="separator:ga569b8b0339e96b41301e1a3305653df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bffe8fe88e2323fbe03fce58cd86e41"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__boost__bst__loop__coeff__t.html">cs40l25_boost_bst_loop_coeff_t</a>&#160;&#160;&#160;<b>boost_bst_loop_coeff</b></td></tr>
<tr class="separator:ga2bffe8fe88e2323fbe03fce58cd86e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f705055d41621ba702f6826260782e8"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__boost__bst__ipk__ctl__t.html">cs40l25_boost_bst_ipk_ctl_t</a>&#160;&#160;&#160;<b>boost_bst_ipk_ctl</b></td></tr>
<tr class="separator:ga0f705055d41621ba702f6826260782e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dad077e6a0b4d0aa1bbc0a759618a20"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__boost__vbst__ctl__1__t.html">cs40l25_boost_vbst_ctl_1_t</a>&#160;&#160;&#160;<b>boost_vbst_ctl_1</b></td></tr>
<tr class="separator:ga1dad077e6a0b4d0aa1bbc0a759618a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d89c770d6cf2612ef29d871bc9f4107"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="unioncs40l25__boost__vbst__ctl__2__t.html">cs40l25_boost_vbst_ctl_2_t</a>&#160;&#160;&#160;<b>boost_vbst_ctl_2</b></td></tr>
<tr class="separator:ga1d89c770d6cf2612ef29d871bc9f4107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9aad53e202a6bee412069a802480f4"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="uniondsp__gpio__button__detect__reg__t.html">dsp_gpio_button_detect_reg_t</a>&#160;&#160;&#160;<b>dsp_gpio_button_detect</b></td></tr>
<tr class="separator:gaec9aad53e202a6bee412069a802480f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c2e905d2e510d21bfe998a54ddaa666"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>dsp_gpio_enable</b></td></tr>
<tr class="separator:ga1c2e905d2e510d21bfe998a54ddaa666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga801c70b75547976af4ea571656bce9dc"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="uniondsp__gain__control__reg__t.html">dsp_gain_control_reg_t</a>&#160;&#160;&#160;<b>dsp_gain_control</b></td></tr>
<tr class="separator:ga801c70b75547976af4ea571656bce9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03ac911a9909cb327a1acc320bb5b09a"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>dsp_gpio1_index_button_press</b></td></tr>
<tr class="separator:ga03ac911a9909cb327a1acc320bb5b09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04f0fafa81a6c73f940cf1839a0a2d89"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>dsp_gpio2_index_button_press</b></td></tr>
<tr class="separator:ga04f0fafa81a6c73f940cf1839a0a2d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad87548519282af6a4a004aad9b243653"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>dsp_gpio3_index_button_press</b></td></tr>
<tr class="separator:gad87548519282af6a4a004aad9b243653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6449f08b344974324917efac365c46fc"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>dsp_gpio4_index_button_press</b></td></tr>
<tr class="separator:ga6449f08b344974324917efac365c46fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9efc6ca49433b9d12fa13593a1b28b2f"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>dsp_gpio1_index_button_release</b></td></tr>
<tr class="separator:ga9efc6ca49433b9d12fa13593a1b28b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b20f1a3eb617ca06b24e89c3762e42c"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>dsp_gpio2_index_button_release</b></td></tr>
<tr class="separator:ga2b20f1a3eb617ca06b24e89c3762e42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab86253b6d346a0efa2b2b03252f33c8"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>dsp_gpio3_index_button_release</b></td></tr>
<tr class="separator:gaab86253b6d346a0efa2b2b03252f33c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd23b20a3b66a0cbf18e01d2cc02cc5"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>dsp_gpio4_index_button_release</b></td></tr>
<tr class="separator:ga2bd23b20a3b66a0cbf18e01d2cc02cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f37c2fc78fc5e102955806ca3bbd0ca"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>clab_enabled</b></td></tr>
<tr class="separator:ga1f37c2fc78fc5e102955806ca3bbd0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8445bd7eda58a9a55e91952184367d2f"><td class="memItemLeft" >
&#160;&#160;&#160;<a class="el" href="uniondsp__reg__t.html">dsp_reg_t</a>&#160;&#160;&#160;<b>peak_amplitude_control</b></td></tr>
<tr class="separator:ga8445bd7eda58a9a55e91952184367d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga171783706fb078addac4177e85a7801d"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:ga171783706fb078addac4177e85a7801d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e76695b0afdd29a3aff48418142a1e3"><td class="memItemLeft" align="right" valign="top"><a id="ga3e76695b0afdd29a3aff48418142a1e3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_dsp_config_controls_t::dsp_gpio1_button_detect_enable</b></td></tr>
<tr class="separator:ga3e76695b0afdd29a3aff48418142a1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b859719172c652edacd44c3c73d6c8c"><td class="memItemLeft" align="right" valign="top"><a id="ga0b859719172c652edacd44c3c73d6c8c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_dsp_config_controls_t::dsp_gpio2_button_detect_enable</b></td></tr>
<tr class="separator:ga0b859719172c652edacd44c3c73d6c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3332c3ca196eab95ba39c8831e62a507"><td class="memItemLeft" align="right" valign="top"><a id="ga3332c3ca196eab95ba39c8831e62a507"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_dsp_config_controls_t::dsp_gpio3_button_detect_enable</b></td></tr>
<tr class="separator:ga3332c3ca196eab95ba39c8831e62a507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf733263027bc9236206cdbe4744b8f07"><td class="memItemLeft" align="right" valign="top"><a id="gaf733263027bc9236206cdbe4744b8f07"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_dsp_config_controls_t::dsp_gpio4_button_detect_enable</b></td></tr>
<tr class="separator:gaf733263027bc9236206cdbe4744b8f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea42f9b64948edcbf3ae0ccf72856e60"><td class="memItemLeft" align="right" valign="top"><a id="gaea42f9b64948edcbf3ae0ccf72856e60"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_dsp_config_controls_t::dsp_gpio_enable</b></td></tr>
<tr class="separator:gaea42f9b64948edcbf3ae0ccf72856e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8afb01ea473a320c4a0dfb92f5a9e76c"><td class="memItemLeft" align="right" valign="top"><a id="ga8afb01ea473a320c4a0dfb92f5a9e76c"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_dsp_config_controls_t::dsp_gpi_gain_control</b></td></tr>
<tr class="separator:ga8afb01ea473a320c4a0dfb92f5a9e76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf140df2c2451315aa79b842213fa2e79"><td class="memItemLeft" align="right" valign="top"><a id="gaf140df2c2451315aa79b842213fa2e79"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_dsp_config_controls_t::dsp_ctrl_gain_control</b></td></tr>
<tr class="separator:gaf140df2c2451315aa79b842213fa2e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef122426f62f5c5e5e458cff5138bac"><td class="memItemLeft" align="right" valign="top"><a id="gafef122426f62f5c5e5e458cff5138bac"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_dsp_config_controls_t::dsp_gpio1_index_button_press</b></td></tr>
<tr class="separator:gafef122426f62f5c5e5e458cff5138bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabda401c80edbf094961594963916e70e"><td class="memItemLeft" align="right" valign="top"><a id="gabda401c80edbf094961594963916e70e"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_dsp_config_controls_t::dsp_gpio2_index_button_press</b></td></tr>
<tr class="separator:gabda401c80edbf094961594963916e70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dc63c189fba1241ddb21cb6adbcdf7d"><td class="memItemLeft" align="right" valign="top"><a id="ga3dc63c189fba1241ddb21cb6adbcdf7d"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_dsp_config_controls_t::dsp_gpio3_index_button_press</b></td></tr>
<tr class="separator:ga3dc63c189fba1241ddb21cb6adbcdf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893c8399997ee7bdb3ec2393ff94edb0"><td class="memItemLeft" align="right" valign="top"><a id="ga893c8399997ee7bdb3ec2393ff94edb0"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_dsp_config_controls_t::dsp_gpio4_index_button_press</b></td></tr>
<tr class="separator:ga893c8399997ee7bdb3ec2393ff94edb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fa83414ecee3a64d6209aef8baa69f7"><td class="memItemLeft" align="right" valign="top"><a id="ga0fa83414ecee3a64d6209aef8baa69f7"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_dsp_config_controls_t::dsp_gpio1_index_button_release</b></td></tr>
<tr class="separator:ga0fa83414ecee3a64d6209aef8baa69f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01d1918abe0733f75ad7a8c3bcb27e98"><td class="memItemLeft" align="right" valign="top"><a id="ga01d1918abe0733f75ad7a8c3bcb27e98"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_dsp_config_controls_t::dsp_gpio2_index_button_release</b></td></tr>
<tr class="separator:ga01d1918abe0733f75ad7a8c3bcb27e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd11eaaf37d3db0249dfff78ab99dce9"><td class="memItemLeft" align="right" valign="top"><a id="gabd11eaaf37d3db0249dfff78ab99dce9"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_dsp_config_controls_t::dsp_gpio3_index_button_release</b></td></tr>
<tr class="separator:gabd11eaaf37d3db0249dfff78ab99dce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb67dc59cc659bb089167d5f754dbb0e"><td class="memItemLeft" align="right" valign="top"><a id="gafb67dc59cc659bb089167d5f754dbb0e"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_dsp_config_controls_t::dsp_gpio4_index_button_release</b></td></tr>
<tr class="separator:gafb67dc59cc659bb089167d5f754dbb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58ffc4afcd6a851ffc637de288570fcb"><td class="memItemLeft" align="right" valign="top"><a id="ga58ffc4afcd6a851ffc637de288570fcb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga58ffc4afcd6a851ffc637de288570fcb">cs40l25_dsp_config_controls_t::clab_enable</a></td></tr>
<tr class="memdesc:ga58ffc4afcd6a851ffc637de288570fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether Closed-loop Active Braking shoud be enabled. <br /></td></tr>
<tr class="separator:ga58ffc4afcd6a851ffc637de288570fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee64b2011e609e854ac070b22155be57"><td class="memItemLeft" align="right" valign="top"><a id="gaee64b2011e609e854ac070b22155be57"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaee64b2011e609e854ac070b22155be57">cs40l25_dsp_config_controls_t::peak_amplitude</a></td></tr>
<tr class="memdesc:gaee64b2011e609e854ac070b22155be57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clab braking pulses are scaled down if they exceed this amplitude. Q2.22. <br /></td></tr>
<tr class="separator:gaee64b2011e609e854ac070b22155be57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga916d8bbb1eff68fa137000c20ac7fa71"><td class="memItemLeft" align="right" valign="top"><a id="ga916d8bbb1eff68fa137000c20ac7fa71"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga916d8bbb1eff68fa137000c20ac7fa71">cs40l25_calibration_t::is_valid_f0</a></td></tr>
<tr class="memdesc:ga916d8bbb1eff68fa137000c20ac7fa71"><td class="mdescLeft">&#160;</td><td class="mdescRight">(True) Calibration state is valid <br /></td></tr>
<tr class="separator:ga916d8bbb1eff68fa137000c20ac7fa71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga832f2397f07a8c7d6662c8707a52155f"><td class="memItemLeft" align="right" valign="top"><a id="ga832f2397f07a8c7d6662c8707a52155f"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga832f2397f07a8c7d6662c8707a52155f">cs40l25_calibration_t::f0</a></td></tr>
<tr class="memdesc:ga832f2397f07a8c7d6662c8707a52155f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encoded resonant frequency (f0) determined by Calibration procedure. <br /></td></tr>
<tr class="separator:ga832f2397f07a8c7d6662c8707a52155f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab00670eb999614ada71de0ddc8010283"><td class="memItemLeft" align="right" valign="top"><a id="gab00670eb999614ada71de0ddc8010283"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gab00670eb999614ada71de0ddc8010283">cs40l25_calibration_t::redc</a></td></tr>
<tr class="memdesc:gab00670eb999614ada71de0ddc8010283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encoded DC resistance (ReDC) determined by Calibration procedure. <br /></td></tr>
<tr class="separator:gab00670eb999614ada71de0ddc8010283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae28aa73b023a54c26ec42887c4694a"><td class="memItemLeft" align="right" valign="top"><a id="ga8ae28aa73b023a54c26ec42887c4694a"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga8ae28aa73b023a54c26ec42887c4694a">cs40l25_calibration_t::backemf</a></td></tr>
<tr class="memdesc:ga8ae28aa73b023a54c26ec42887c4694a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encoded Back EMF determined by Calibration procedure. <br /></td></tr>
<tr class="separator:ga8ae28aa73b023a54c26ec42887c4694a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bb908acc7db4eec34ce54d5623b589f"><td class="memItemLeft" align="right" valign="top"><a id="ga1bb908acc7db4eec34ce54d5623b589f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga1bb908acc7db4eec34ce54d5623b589f">cs40l25_calibration_t::is_valid_qest</a></td></tr>
<tr class="memdesc:ga1bb908acc7db4eec34ce54d5623b589f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(True) Calibration state is valid <br /></td></tr>
<tr class="separator:ga1bb908acc7db4eec34ce54d5623b589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga006ceda93d3dad5106a778982783164f"><td class="memItemLeft" align="right" valign="top"><a id="ga006ceda93d3dad5106a778982783164f"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga006ceda93d3dad5106a778982783164f">cs40l25_calibration_t::qest</a></td></tr>
<tr class="memdesc:ga006ceda93d3dad5106a778982783164f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encoded estimated Q value (Q Est) determined by Calibration procedure. <br /></td></tr>
<tr class="separator:ga006ceda93d3dad5106a778982783164f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4853b65d2e8247d678de05ec993a561e"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_dsp_status_t::words</b> [<a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga5bef175dd06efddb80992ccbb7c2ad69">CS40L25_DSP_STATUS_WORDS_TOTAL</a>]</td></tr>
<tr class="separator:ga4853b65d2e8247d678de05ec993a561e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2424aa6aaa571ea9b51079d3ceffb9d9"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_dsp_status_t::::halo_state</b></td></tr>
<tr class="separator:ga2424aa6aaa571ea9b51079d3ceffb9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f8cc71d64ff498bc43cd800274b882"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_dsp_status_t::::halo_heartbeat</b></td></tr>
<tr class="separator:ga44f8cc71d64ff498bc43cd800274b882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7633454b00357204ed76212c57747aae"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_dsp_status_t::::cspl_state</b></td></tr>
<tr class="separator:ga7633454b00357204ed76212c57747aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d4d4bd0dc639effa25a51e9a3cce88b"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_dsp_status_t::::cal_set_status</b></td></tr>
<tr class="separator:ga0d4d4bd0dc639effa25a51e9a3cce88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga335d75ae468363a8ccc53fb592c53ccf"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_dsp_status_t::::cal_r_selected</b></td></tr>
<tr class="separator:ga335d75ae468363a8ccc53fb592c53ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc83cf8d1138f9fc68fcbd580c632552"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_dsp_status_t::::cal_r</b></td></tr>
<tr class="separator:gabc83cf8d1138f9fc68fcbd580c632552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6daf765d9e22dfab43e546456af3fdd4"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_dsp_status_t::::cal_status</b></td></tr>
<tr class="separator:ga6daf765d9e22dfab43e546456af3fdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211aa1457e7e721861f99a85bc5862d2"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_dsp_status_t::::cal_checksum</b></td></tr>
<tr class="separator:ga211aa1457e7e721861f99a85bc5862d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01b3235ebc76202bcb8308157cd64400"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_dsp_status_t::::cspl_temperature</b></td></tr>
<tr class="separator:ga01b3235ebc76202bcb8308157cd64400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b54d7c8661110c424155a651063d3f3"><td class="memItemLeft" ><a id="ga8b54d7c8661110c424155a651063d3f3"></a>
struct {</td></tr>
<tr class="memitem:ga2424aa6aaa571ea9b51079d3ceffb9d9"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>halo_state</b></td></tr>
<tr class="separator:ga2424aa6aaa571ea9b51079d3ceffb9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f8cc71d64ff498bc43cd800274b882"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>halo_heartbeat</b></td></tr>
<tr class="separator:ga44f8cc71d64ff498bc43cd800274b882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7633454b00357204ed76212c57747aae"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>cspl_state</b></td></tr>
<tr class="separator:ga7633454b00357204ed76212c57747aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d4d4bd0dc639effa25a51e9a3cce88b"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>cal_set_status</b></td></tr>
<tr class="separator:ga0d4d4bd0dc639effa25a51e9a3cce88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga335d75ae468363a8ccc53fb592c53ccf"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>cal_r_selected</b></td></tr>
<tr class="separator:ga335d75ae468363a8ccc53fb592c53ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc83cf8d1138f9fc68fcbd580c632552"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>cal_r</b></td></tr>
<tr class="separator:gabc83cf8d1138f9fc68fcbd580c632552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6daf765d9e22dfab43e546456af3fdd4"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>cal_status</b></td></tr>
<tr class="separator:ga6daf765d9e22dfab43e546456af3fdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211aa1457e7e721861f99a85bc5862d2"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>cal_checksum</b></td></tr>
<tr class="separator:ga211aa1457e7e721861f99a85bc5862d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01b3235ebc76202bcb8308157cd64400"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>cspl_temperature</b></td></tr>
<tr class="separator:ga01b3235ebc76202bcb8308157cd64400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b54d7c8661110c424155a651063d3f3"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:ga8b54d7c8661110c424155a651063d3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b5bf14941abe9cab8ad46ea8297815f"><td class="memItemLeft" ><a id="ga8b5bf14941abe9cab8ad46ea8297815f"></a>
union {</td></tr>
<tr class="memitem:ga4853b65d2e8247d678de05ec993a561e"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>words</b> [<a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga5bef175dd06efddb80992ccbb7c2ad69">CS40L25_DSP_STATUS_WORDS_TOTAL</a>]</td></tr>
<tr class="separator:ga4853b65d2e8247d678de05ec993a561e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b54d7c8661110c424155a651063d3f3"><td class="memItemLeft" ><a id="ga8b54d7c8661110c424155a651063d3f3"></a>
&#160;&#160;&#160;struct {</td></tr>
<tr class="memitem:ga2424aa6aaa571ea9b51079d3ceffb9d9"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>halo_state</b></td></tr>
<tr class="separator:ga2424aa6aaa571ea9b51079d3ceffb9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f8cc71d64ff498bc43cd800274b882"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>halo_heartbeat</b></td></tr>
<tr class="separator:ga44f8cc71d64ff498bc43cd800274b882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7633454b00357204ed76212c57747aae"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>cspl_state</b></td></tr>
<tr class="separator:ga7633454b00357204ed76212c57747aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d4d4bd0dc639effa25a51e9a3cce88b"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>cal_set_status</b></td></tr>
<tr class="separator:ga0d4d4bd0dc639effa25a51e9a3cce88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga335d75ae468363a8ccc53fb592c53ccf"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>cal_r_selected</b></td></tr>
<tr class="separator:ga335d75ae468363a8ccc53fb592c53ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc83cf8d1138f9fc68fcbd580c632552"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>cal_r</b></td></tr>
<tr class="separator:gabc83cf8d1138f9fc68fcbd580c632552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6daf765d9e22dfab43e546456af3fdd4"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>cal_status</b></td></tr>
<tr class="separator:ga6daf765d9e22dfab43e546456af3fdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211aa1457e7e721861f99a85bc5862d2"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>cal_checksum</b></td></tr>
<tr class="separator:ga211aa1457e7e721861f99a85bc5862d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01b3235ebc76202bcb8308157cd64400"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>cspl_temperature</b></td></tr>
<tr class="separator:ga01b3235ebc76202bcb8308157cd64400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b54d7c8661110c424155a651063d3f3"><td class="memItemLeft" valign="top">&#160;&#160;&#160;}&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:ga8b54d7c8661110c424155a651063d3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b5bf14941abe9cab8ad46ea8297815f"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga8b5bf14941abe9cab8ad46ea8297815f">cs40l25_dsp_status_t::data</a></td></tr>
<tr class="memdesc:ga8b5bf14941abe9cab8ad46ea8297815f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data read from Control Port. <br /></td></tr>
<tr class="separator:ga8b5bf14941abe9cab8ad46ea8297815f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a2f815eef73dccc5917cb3eabe5dfa8"><td class="memItemLeft" align="right" valign="top"><a id="ga6a2f815eef73dccc5917cb3eabe5dfa8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga6a2f815eef73dccc5917cb3eabe5dfa8">cs40l25_dsp_status_t::is_hb_inc</a></td></tr>
<tr class="memdesc:ga6a2f815eef73dccc5917cb3eabe5dfa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(True) The HALO HEARTBEAT is incrementing <br /></td></tr>
<tr class="separator:ga6a2f815eef73dccc5917cb3eabe5dfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d849f6dcc79209a24846e8b475b3e43"><td class="memItemLeft" align="right" valign="top"><a id="ga3d849f6dcc79209a24846e8b475b3e43"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga3d849f6dcc79209a24846e8b475b3e43">cs40l25_dsp_status_t::is_calibration_applied</a></td></tr>
<tr class="memdesc:ga3d849f6dcc79209a24846e8b475b3e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">(True) Calibration values are applied <br /></td></tr>
<tr class="separator:ga3d849f6dcc79209a24846e8b475b3e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2df56fd7967d8d4c2d6c473594aa0515"><td class="memItemLeft" align="right" valign="top"><a id="ga2df56fd7967d8d4c2d6c473594aa0515"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga2df56fd7967d8d4c2d6c473594aa0515">cs40l25_dsp_status_t::is_temp_changed</a></td></tr>
<tr class="memdesc:ga2df56fd7967d8d4c2d6c473594aa0515"><td class="mdescLeft">&#160;</td><td class="mdescRight">(True) Monitored temperature is varying. <br /></td></tr>
<tr class="separator:ga2df56fd7967d8d4c2d6c473594aa0515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7762f1aed3e00faa114abc259596346"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_fw_revision_t::word</b></td></tr>
<tr class="separator:gad7762f1aed3e00faa114abc259596346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e7fd2d623f379f9fa40f22fdd91e057"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_fw_revision_t::::patch</b>: 8</td></tr>
<tr class="separator:ga2e7fd2d623f379f9fa40f22fdd91e057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e908b484190c47d014a624b9a39fe7"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_fw_revision_t::::minor</b>: 8</td></tr>
<tr class="separator:ga53e908b484190c47d014a624b9a39fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc5b5f875b6b1c2c163dbaada29a17a"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_fw_revision_t::::major</b>: 8</td></tr>
<tr class="separator:ga4bc5b5f875b6b1c2c163dbaada29a17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf548d8dfe14c44cc12f15f270b7cb95b"><td class="memItemLeft" >
uint32_t&#160;&#160;&#160;<b>cs40l25_fw_revision_t::::reserved</b>: 8</td></tr>
<tr class="separator:gaf548d8dfe14c44cc12f15f270b7cb95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64264bf2d4514603959e8602d7cb7a70"><td class="memItemLeft" ><a id="ga64264bf2d4514603959e8602d7cb7a70"></a>
struct {</td></tr>
<tr class="memitem:ga2e7fd2d623f379f9fa40f22fdd91e057"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>patch</b>: 8</td></tr>
<tr class="separator:ga2e7fd2d623f379f9fa40f22fdd91e057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e908b484190c47d014a624b9a39fe7"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>minor</b>: 8</td></tr>
<tr class="separator:ga53e908b484190c47d014a624b9a39fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc5b5f875b6b1c2c163dbaada29a17a"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>major</b>: 8</td></tr>
<tr class="separator:ga4bc5b5f875b6b1c2c163dbaada29a17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf548d8dfe14c44cc12f15f270b7cb95b"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>reserved</b>: 8</td></tr>
<tr class="separator:gaf548d8dfe14c44cc12f15f270b7cb95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64264bf2d4514603959e8602d7cb7a70"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:ga64264bf2d4514603959e8602d7cb7a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf75d69d7a7e6ed007440f402c718e8ef"><td class="memItemLeft" ><a id="gaf75d69d7a7e6ed007440f402c718e8ef"></a>
union {</td></tr>
<tr class="memitem:gad7762f1aed3e00faa114abc259596346"><td class="memItemLeft" >
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>word</b></td></tr>
<tr class="separator:gad7762f1aed3e00faa114abc259596346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64264bf2d4514603959e8602d7cb7a70"><td class="memItemLeft" ><a id="ga64264bf2d4514603959e8602d7cb7a70"></a>
&#160;&#160;&#160;struct {</td></tr>
<tr class="memitem:ga2e7fd2d623f379f9fa40f22fdd91e057"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>patch</b>: 8</td></tr>
<tr class="separator:ga2e7fd2d623f379f9fa40f22fdd91e057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e908b484190c47d014a624b9a39fe7"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>minor</b>: 8</td></tr>
<tr class="separator:ga53e908b484190c47d014a624b9a39fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc5b5f875b6b1c2c163dbaada29a17a"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>major</b>: 8</td></tr>
<tr class="separator:ga4bc5b5f875b6b1c2c163dbaada29a17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf548d8dfe14c44cc12f15f270b7cb95b"><td class="memItemLeft" >
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>reserved</b>: 8</td></tr>
<tr class="separator:gaf548d8dfe14c44cc12f15f270b7cb95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64264bf2d4514603959e8602d7cb7a70"><td class="memItemLeft" valign="top">&#160;&#160;&#160;}&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:ga64264bf2d4514603959e8602d7cb7a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf75d69d7a7e6ed007440f402c718e8ef"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:gaf75d69d7a7e6ed007440f402c718e8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ad303e9a6f79190e69c869fa07a3a3a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga6ad303e9a6f79190e69c869fa07a3a3a">cs40l25_t::state</a></td></tr>
<tr class="memdesc:ga6ad303e9a6f79190e69c869fa07a3a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">General driver state -.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga6ad303e9a6f79190e69c869fa07a3a3a">More...</a><br /></td></tr>
<tr class="separator:ga6ad303e9a6f79190e69c869fa07a3a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga233b14740e59b9641955a68ee76f5470"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga233b14740e59b9641955a68ee76f5470">cs40l25_t::mode</a></td></tr>
<tr class="memdesc:ga233b14740e59b9641955a68ee76f5470"><td class="mdescLeft">&#160;</td><td class="mdescRight">General driver mode -.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga233b14740e59b9641955a68ee76f5470">More...</a><br /></td></tr>
<tr class="separator:ga233b14740e59b9641955a68ee76f5470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ec19760a1f321f6c2fcc56ae88ba94c"><td class="memItemLeft" align="right" valign="top"><a id="ga8ec19760a1f321f6c2fcc56ae88ba94c"></a>
<a class="el" href="structcs40l25__sm__t.html">cs40l25_sm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga8ec19760a1f321f6c2fcc56ae88ba94c">cs40l25_t::control_sm</a></td></tr>
<tr class="memdesc:ga8ec19760a1f321f6c2fcc56ae88ba94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control State Machine for current Control Request. <br /></td></tr>
<tr class="separator:ga8ec19760a1f321f6c2fcc56ae88ba94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35cf6264b4e4b81c1b9e771a95379d94"><td class="memItemLeft" align="right" valign="top"><a id="ga35cf6264b4e4b81c1b9e771a95379d94"></a>
<a class="el" href="structcs40l25__sm__t.html">cs40l25_sm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga35cf6264b4e4b81c1b9e771a95379d94">cs40l25_t::event_sm</a></td></tr>
<tr class="memdesc:ga35cf6264b4e4b81c1b9e771a95379d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event Handler State Machine. <br /></td></tr>
<tr class="separator:ga35cf6264b4e4b81c1b9e771a95379d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bb8a07e72536c908a54c5101f12527f"><td class="memItemLeft" align="right" valign="top"><a id="ga5bb8a07e72536c908a54c5101f12527f"></a>
<a class="el" href="structf__queue__t.html">f_queue_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga5bb8a07e72536c908a54c5101f12527f">cs40l25_t::control_q</a></td></tr>
<tr class="memdesc:ga5bb8a07e72536c908a54c5101f12527f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue of Control Requests. <br /></td></tr>
<tr class="separator:ga5bb8a07e72536c908a54c5101f12527f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa36213bc93e7d0aeedbc9a7c0e9cb227"><td class="memItemLeft" align="right" valign="top"><a id="gaa36213bc93e7d0aeedbc9a7c0e9cb227"></a>
<a class="el" href="structcs40l25__control__request__t.html">cs40l25_control_request_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaa36213bc93e7d0aeedbc9a7c0e9cb227">cs40l25_t::control_requests</a> [<a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaf636142b8de71f4a24a729bd9c2c9081">CS40L25_CONTROL_REQUESTS_SIZE</a>]</td></tr>
<tr class="memdesc:gaa36213bc93e7d0aeedbc9a7c0e9cb227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffered Control Requests. <br /></td></tr>
<tr class="separator:gaa36213bc93e7d0aeedbc9a7c0e9cb227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c16f1ba502d46a7d986b4d3589c253f"><td class="memItemLeft" align="right" valign="top"><a id="ga7c16f1ba502d46a7d986b4d3589c253f"></a>
<a class="el" href="structcs40l25__control__request__t.html">cs40l25_control_request_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga7c16f1ba502d46a7d986b4d3589c253f">cs40l25_t::current_request</a></td></tr>
<tr class="memdesc:ga7c16f1ba502d46a7d986b4d3589c253f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current Control Request. <br /></td></tr>
<tr class="separator:ga7c16f1ba502d46a7d986b4d3589c253f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a9a4aa1781c239b1c2e7d00c255950e"><td class="memItemLeft" align="right" valign="top"><a id="ga0a9a4aa1781c239b1c2e7d00c255950e"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga0a9a4aa1781c239b1c2e7d00c255950e">cs40l25_t::register_buffer</a></td></tr>
<tr class="memdesc:ga0a9a4aa1781c239b1c2e7d00c255950e"><td class="mdescLeft">&#160;</td><td class="mdescRight">buffer for reading Control Port registers <br /></td></tr>
<tr class="separator:ga0a9a4aa1781c239b1c2e7d00c255950e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9fdb65c8601ec85914d910e28720b3"><td class="memItemLeft" align="right" valign="top"><a id="gade9fdb65c8601ec85914d910e28720b3"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gade9fdb65c8601ec85914d910e28720b3">cs40l25_t::devid</a></td></tr>
<tr class="memdesc:gade9fdb65c8601ec85914d910e28720b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CS40L25 DEVID of current device. <br /></td></tr>
<tr class="separator:gade9fdb65c8601ec85914d910e28720b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27bfdd3f0ced1f19b7091e60b12c9aff"><td class="memItemLeft" align="right" valign="top"><a id="ga27bfdd3f0ced1f19b7091e60b12c9aff"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga27bfdd3f0ced1f19b7091e60b12c9aff">cs40l25_t::revid</a></td></tr>
<tr class="memdesc:ga27bfdd3f0ced1f19b7091e60b12c9aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">CS40L25 REVID of current device. <br /></td></tr>
<tr class="separator:ga27bfdd3f0ced1f19b7091e60b12c9aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31da27317673c3bf2bcea8d322f767e2"><td class="memItemLeft" align="right" valign="top"><a id="ga31da27317673c3bf2bcea8d322f767e2"></a>
const uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga31da27317673c3bf2bcea8d322f767e2">cs40l25_t::errata</a></td></tr>
<tr class="memdesc:ga31da27317673c3bf2bcea8d322f767e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to relevant errata for the current device. <br /></td></tr>
<tr class="separator:ga31da27317673c3bf2bcea8d322f767e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9952290d7e7e393c20a50a5600c1336b"><td class="memItemLeft" align="right" valign="top"><a id="ga9952290d7e7e393c20a50a5600c1336b"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga9952290d7e7e393c20a50a5600c1336b">cs40l25_t::mbox_cmd</a></td></tr>
<tr class="memdesc:ga9952290d7e7e393c20a50a5600c1336b"><td class="mdescLeft">&#160;</td><td class="mdescRight">HALO FW Mailbox command to be sent. <br /></td></tr>
<tr class="separator:ga9952290d7e7e393c20a50a5600c1336b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7b416bb1af6c6ce89dd067d25db4762"><td class="memItemLeft" align="right" valign="top"><a id="gab7b416bb1af6c6ce89dd067d25db4762"></a>
<a class="el" href="unioncs40l25__config__registers__t.html">cs40l25_config_registers_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gab7b416bb1af6c6ce89dd067d25db4762">cs40l25_t::config_regs</a></td></tr>
<tr class="memdesc:gab7b416bb1af6c6ce89dd067d25db4762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contents of Control Port registers to configure. <br /></td></tr>
<tr class="separator:gab7b416bb1af6c6ce89dd067d25db4762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ac8afb33e2959dedc6c626784f07a53"><td class="memItemLeft" align="right" valign="top"><a id="ga3ac8afb33e2959dedc6c626784f07a53"></a>
<a class="el" href="structcs40l25__dsp__config__controls__t.html">cs40l25_dsp_config_controls_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga3ac8afb33e2959dedc6c626784f07a53">cs40l25_t::dsp_config_ctrls</a></td></tr>
<tr class="memdesc:ga3ac8afb33e2959dedc6c626784f07a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configurable DSP controls. <br /></td></tr>
<tr class="separator:ga3ac8afb33e2959dedc6c626784f07a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca5da335763bc8c71708a53c0cc8f46"><td class="memItemLeft" align="right" valign="top"><a id="ga7ca5da335763bc8c71708a53c0cc8f46"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_t::calib_pcm_vol</b></td></tr>
<tr class="separator:ga7ca5da335763bc8c71708a53c0cc8f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2db06660a8f4a54e9b259666f8080c38"><td class="memItemLeft" align="right" valign="top"><a id="ga2db06660a8f4a54e9b259666f8080c38"></a>
<a class="el" href="structcs40l25__field__accessor__t.html">cs40l25_field_accessor_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga2db06660a8f4a54e9b259666f8080c38">cs40l25_t::field_accessor</a></td></tr>
<tr class="memdesc:ga2db06660a8f4a54e9b259666f8080c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current Control Port field to access. <br /></td></tr>
<tr class="separator:ga2db06660a8f4a54e9b259666f8080c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9621d0c8721ff273b0aba5f8c5452c3"><td class="memItemLeft" align="right" valign="top"><a id="gaf9621d0c8721ff273b0aba5f8c5452c3"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_t::bsp_dev_id</b></td></tr>
<tr class="separator:gaf9621d0c8721ff273b0aba5f8c5452c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf375b4b6d118c2cdf2b7937133082ea"><td class="memItemLeft" align="right" valign="top"><a id="gabf375b4b6d118c2cdf2b7937133082ea"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_t::bsp_reset_gpio_id</b></td></tr>
<tr class="separator:gabf375b4b6d118c2cdf2b7937133082ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6df0f8c0592fb125ba2c59704283b350"><td class="memItemLeft" align="right" valign="top"><a id="ga6df0f8c0592fb125ba2c59704283b350"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_t::bsp_int_gpio_id</b></td></tr>
<tr class="separator:ga6df0f8c0592fb125ba2c59704283b350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7664675b7fcdb5e871667f153c2621db"><td class="memItemLeft" align="right" valign="top"><a id="ga7664675b7fcdb5e871667f153c2621db"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_t::bus_type</b></td></tr>
<tr class="separator:ga7664675b7fcdb5e871667f153c2621db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ed95b8d36c913c0708276492442f83"><td class="memItemLeft" align="right" valign="top"><a id="ga42ed95b8d36c913c0708276492442f83"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_t::cp_write_buffer</b></td></tr>
<tr class="separator:ga42ed95b8d36c913c0708276492442f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94e25b4916158c3f2e8e3f8c2763e9ef"><td class="memItemLeft" align="right" valign="top"><a id="ga94e25b4916158c3f2e8e3f8c2763e9ef"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_t::cp_read_buffer</b></td></tr>
<tr class="separator:ga94e25b4916158c3f2e8e3f8c2763e9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bee3a436201ab68d78f61acc9393d80"><td class="memItemLeft" align="right" valign="top"><a id="ga2bee3a436201ab68d78f61acc9393d80"></a>
<a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga0b78156f6addb3f1db4918f59f2ac6c9">cs40l25_notification_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_t::notification_cb</b></td></tr>
<tr class="separator:ga2bee3a436201ab68d78f61acc9393d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cf8dde61988540eec0e830bc2a474f8"><td class="memItemLeft" align="right" valign="top"><a id="ga3cf8dde61988540eec0e830bc2a474f8"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_t::notification_cb_arg</b></td></tr>
<tr class="separator:ga3cf8dde61988540eec0e830bc2a474f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d5f595d3d4fd1c3e8b2ab57278342f2"><td class="memItemLeft" align="right" valign="top"><a id="ga0d5f595d3d4fd1c3e8b2ab57278342f2"></a>
<a class="el" href="structcs40l25__audio__config__t.html">cs40l25_audio_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_t::audio_config</b></td></tr>
<tr class="separator:ga0d5f595d3d4fd1c3e8b2ab57278342f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e2f0116ee567a0e34d36b7c31f06339"><td class="memItemLeft" align="right" valign="top"><a id="ga6e2f0116ee567a0e34d36b7c31f06339"></a>
<a class="el" href="structcs40l25__amp__config__t.html">cs40l25_amp_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_t::amp_config</b></td></tr>
<tr class="separator:ga6e2f0116ee567a0e34d36b7c31f06339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ab8e30560471fffef4aeb21e7b53717"><td class="memItemLeft" align="right" valign="top"><a id="ga4ab8e30560471fffef4aeb21e7b53717"></a>
<a class="el" href="structcs40l25__calibration__t.html">cs40l25_calibration_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cs40l25_t::cal_data</b></td></tr>
<tr class="separator:ga4ab8e30560471fffef4aeb21e7b53717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga023a0a9ede69dffb8a2d1d2ae9eb688b"><td class="memItemLeft" align="right" valign="top"><a id="ga023a0a9ede69dffb8a2d1d2ae9eb688b"></a>
<a class="el" href="structcs40l25__boot__config__t.html">cs40l25_boot_config_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga023a0a9ede69dffb8a2d1d2ae9eb688b">cs40l25_t::boot_config</a></td></tr>
<tr class="memdesc:ga023a0a9ede69dffb8a2d1d2ae9eb688b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current HALO FW/Coefficient boot configuration. <br /></td></tr>
<tr class="separator:ga023a0a9ede69dffb8a2d1d2ae9eb688b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a815c197f89f59bd7eb8ffaa583ddd7"><td class="memItemLeft" align="right" valign="top"><a id="ga8a815c197f89f59bd7eb8ffaa583ddd7"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga8a815c197f89f59bd7eb8ffaa583ddd7">cs40l25_config_t::bsp_dev_id</a></td></tr>
<tr class="memdesc:ga8a815c197f89f59bd7eb8ffaa583ddd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to ID CS40L25 in bsp_driver_if calls. <br /></td></tr>
<tr class="separator:ga8a815c197f89f59bd7eb8ffaa583ddd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff9e0b40979c892a288e78bddb2c93c"><td class="memItemLeft" align="right" valign="top"><a id="ga7ff9e0b40979c892a288e78bddb2c93c"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga7ff9e0b40979c892a288e78bddb2c93c">cs40l25_config_t::bsp_reset_gpio_id</a></td></tr>
<tr class="memdesc:ga7ff9e0b40979c892a288e78bddb2c93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to ID CS40L25 Reset pin in bsp_driver_if calls. <br /></td></tr>
<tr class="separator:ga7ff9e0b40979c892a288e78bddb2c93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6b54c751a88e8e08d22422094bb5f56"><td class="memItemLeft" align="right" valign="top"><a id="gac6b54c751a88e8e08d22422094bb5f56"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gac6b54c751a88e8e08d22422094bb5f56">cs40l25_config_t::bsp_int_gpio_id</a></td></tr>
<tr class="memdesc:gac6b54c751a88e8e08d22422094bb5f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to ID CS40L25 INT pin in bsp_driver_if calls. <br /></td></tr>
<tr class="separator:gac6b54c751a88e8e08d22422094bb5f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7b8053600a6fc8f2197637660d08918"><td class="memItemLeft" align="right" valign="top"><a id="gaf7b8053600a6fc8f2197637660d08918"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaf7b8053600a6fc8f2197637660d08918">cs40l25_config_t::bus_type</a></td></tr>
<tr class="memdesc:gaf7b8053600a6fc8f2197637660d08918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control Port type - I2C or SPI. <br /></td></tr>
<tr class="separator:gaf7b8053600a6fc8f2197637660d08918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f2f90bb5a8261b2581e39009cda182c"><td class="memItemLeft" align="right" valign="top"><a id="ga7f2f90bb5a8261b2581e39009cda182c"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga7f2f90bb5a8261b2581e39009cda182c">cs40l25_config_t::cp_write_buffer</a></td></tr>
<tr class="memdesc:ga7f2f90bb5a8261b2581e39009cda182c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Control Port write byte buffer. <br /></td></tr>
<tr class="separator:ga7f2f90bb5a8261b2581e39009cda182c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08413d0be1f16a66d646b83569b5b531"><td class="memItemLeft" align="right" valign="top"><a id="ga08413d0be1f16a66d646b83569b5b531"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga08413d0be1f16a66d646b83569b5b531">cs40l25_config_t::cp_read_buffer</a></td></tr>
<tr class="memdesc:ga08413d0be1f16a66d646b83569b5b531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Control Port read byte buffer. <br /></td></tr>
<tr class="separator:ga08413d0be1f16a66d646b83569b5b531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a60d7aa7688c330b39cb3cd8ea21d50"><td class="memItemLeft" align="right" valign="top"><a id="ga5a60d7aa7688c330b39cb3cd8ea21d50"></a>
<a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga0b78156f6addb3f1db4918f59f2ac6c9">cs40l25_notification_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga5a60d7aa7688c330b39cb3cd8ea21d50">cs40l25_config_t::notification_cb</a></td></tr>
<tr class="memdesc:ga5a60d7aa7688c330b39cb3cd8ea21d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification callback registered for detected events. <br /></td></tr>
<tr class="separator:ga5a60d7aa7688c330b39cb3cd8ea21d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5868ae1db251f8092120dc07ede2106"><td class="memItemLeft" align="right" valign="top"><a id="gaa5868ae1db251f8092120dc07ede2106"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaa5868ae1db251f8092120dc07ede2106">cs40l25_config_t::notification_cb_arg</a></td></tr>
<tr class="memdesc:gaa5868ae1db251f8092120dc07ede2106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification callback argument. <br /></td></tr>
<tr class="separator:gaa5868ae1db251f8092120dc07ede2106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc9da17e3486c3baab7d62ef79a8434"><td class="memItemLeft" align="right" valign="top"><a id="gacdc9da17e3486c3baab7d62ef79a8434"></a>
<a class="el" href="structcs40l25__audio__config__t.html">cs40l25_audio_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gacdc9da17e3486c3baab7d62ef79a8434">cs40l25_config_t::audio_config</a></td></tr>
<tr class="memdesc:gacdc9da17e3486c3baab7d62ef79a8434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amplifier audio-related configuration. <br /></td></tr>
<tr class="separator:gacdc9da17e3486c3baab7d62ef79a8434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac713190ea2e056727332d0d953f31554"><td class="memItemLeft" align="right" valign="top"><a id="gac713190ea2e056727332d0d953f31554"></a>
<a class="el" href="structcs40l25__amp__config__t.html">cs40l25_amp_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gac713190ea2e056727332d0d953f31554">cs40l25_config_t::amp_config</a></td></tr>
<tr class="memdesc:gac713190ea2e056727332d0d953f31554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amplifier amp-related configuration. <br /></td></tr>
<tr class="separator:gac713190ea2e056727332d0d953f31554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeba1c450b26f08a7fe025e24b8275b1c"><td class="memItemLeft" align="right" valign="top"><a id="gaeba1c450b26f08a7fe025e24b8275b1c"></a>
<a class="el" href="structcs40l25__calibration__t.html">cs40l25_calibration_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaeba1c450b26f08a7fe025e24b8275b1c">cs40l25_config_t::cal_data</a></td></tr>
<tr class="memdesc:gaeba1c450b26f08a7fe025e24b8275b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibration data from previous calibration sequence. <br /></td></tr>
<tr class="separator:gaeba1c450b26f08a7fe025e24b8275b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga884328d21f7aae33a3b48aecc6ae1c5b"><td class="memItemLeft" align="right" valign="top"><a id="ga884328d21f7aae33a3b48aecc6ae1c5b"></a>
<a class="el" href="structcs40l25__dsp__config__controls__t.html">cs40l25_dsp_config_controls_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga884328d21f7aae33a3b48aecc6ae1c5b">cs40l25_config_t::dsp_config_ctrls</a></td></tr>
<tr class="memdesc:ga884328d21f7aae33a3b48aecc6ae1c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configurable DSP controls. <br /></td></tr>
<tr class="separator:ga884328d21f7aae33a3b48aecc6ae1c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe90b157dc3e0351bbd034e6bdca36d4"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gabe90b157dc3e0351bbd034e6bdca36d4">cs40l25_functions_t::initialize</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td></tr>
<tr class="memdesc:gabe90b157dc3e0351bbd034e6bdca36d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize driver state/handle.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gabe90b157dc3e0351bbd034e6bdca36d4">More...</a><br /></td></tr>
<tr class="separator:gabe90b157dc3e0351bbd034e6bdca36d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63d523c9c110048551ac56e6b8f20c4c"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga63d523c9c110048551ac56e6b8f20c4c">cs40l25_functions_t::configure</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, <a class="el" href="structcs40l25__config__t.html">cs40l25_config_t</a> *config)</td></tr>
<tr class="memdesc:ga63d523c9c110048551ac56e6b8f20c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures driver state/handle.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga63d523c9c110048551ac56e6b8f20c4c">More...</a><br /></td></tr>
<tr class="separator:ga63d523c9c110048551ac56e6b8f20c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ea0a047dcf2a0b103d4c0607eba04fb"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga1ea0a047dcf2a0b103d4c0607eba04fb">cs40l25_functions_t::process</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td></tr>
<tr class="memdesc:ga1ea0a047dcf2a0b103d4c0607eba04fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes driver state machines.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga1ea0a047dcf2a0b103d4c0607eba04fb">More...</a><br /></td></tr>
<tr class="separator:ga1ea0a047dcf2a0b103d4c0607eba04fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2f1a666e1c4a785ed0b3bbdfd9d189a"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaa2f1a666e1c4a785ed0b3bbdfd9d189a">cs40l25_functions_t::control</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, <a class="el" href="structcs40l25__control__request__t.html">cs40l25_control_request_t</a> req)</td></tr>
<tr class="memdesc:gaa2f1a666e1c4a785ed0b3bbdfd9d189a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a Control Request to the driver.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaa2f1a666e1c4a785ed0b3bbdfd9d189a">More...</a><br /></td></tr>
<tr class="separator:gaa2f1a666e1c4a785ed0b3bbdfd9d189a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35c203ed780b02fd7331c0f3ce86c603"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga35c203ed780b02fd7331c0f3ce86c603">cs40l25_functions_t::reset</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, <a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga44fbc7618e0385fff020c153a1651c71">cs40l25_control_callback_t</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga35c203ed780b02fd7331c0f3ce86c603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the CS40L25.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga35c203ed780b02fd7331c0f3ce86c603">More...</a><br /></td></tr>
<tr class="separator:ga35c203ed780b02fd7331c0f3ce86c603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf3acbe80b123d357c9c7a48e69f3208"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gacf3acbe80b123d357c9c7a48e69f3208">cs40l25_functions_t::boot</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, bool cal_boot, <a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga44fbc7618e0385fff020c153a1651c71">cs40l25_control_callback_t</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:gacf3acbe80b123d357c9c7a48e69f3208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot the CS40L25.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gacf3acbe80b123d357c9c7a48e69f3208">More...</a><br /></td></tr>
<tr class="separator:gacf3acbe80b123d357c9c7a48e69f3208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fa8d396ac536e9780fc567370ddddc"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga37fa8d396ac536e9780fc567370ddddc">cs40l25_functions_t::power</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, uint32_t power_state, <a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga44fbc7618e0385fff020c153a1651c71">cs40l25_control_callback_t</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga37fa8d396ac536e9780fc567370ddddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the power state.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga37fa8d396ac536e9780fc567370ddddc">More...</a><br /></td></tr>
<tr class="separator:ga37fa8d396ac536e9780fc567370ddddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2b2830798a2cd2da8c82af686d516fd"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gab2b2830798a2cd2da8c82af686d516fd">cs40l25_functions_t::calibrate</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, uint32_t calib_type, <a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga44fbc7618e0385fff020c153a1651c71">cs40l25_control_callback_t</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:gab2b2830798a2cd2da8c82af686d516fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrate the HALO DSP Protection Algorithm.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gab2b2830798a2cd2da8c82af686d516fd">More...</a><br /></td></tr>
<tr class="separator:gab2b2830798a2cd2da8c82af686d516fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9507f9288e1030310c30486d45c52547"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga9507f9288e1030310c30486d45c52547">cs40l25_private_functions_t::timer_callback</a> )(uint32_t status, void *cb_arg)</td></tr>
<tr class="memdesc:ga9507f9288e1030310c30486d45c52547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the driver when the BSP Timer expires.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga9507f9288e1030310c30486d45c52547">More...</a><br /></td></tr>
<tr class="separator:ga9507f9288e1030310c30486d45c52547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf971a22da1b6145717662b82e91a8cf"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaaf971a22da1b6145717662b82e91a8cf">cs40l25_private_functions_t::cp_read_callback</a> )(uint32_t status, void *cb_arg)</td></tr>
<tr class="memdesc:gaaf971a22da1b6145717662b82e91a8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the driver when the BSP Control Port (cp) read transaction completes.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaaf971a22da1b6145717662b82e91a8cf">More...</a><br /></td></tr>
<tr class="separator:gaaf971a22da1b6145717662b82e91a8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3729e80758b35ee2a2224a62a43c99f8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga3729e80758b35ee2a2224a62a43c99f8">cs40l25_private_functions_t::cp_write_callback</a> )(uint32_t status, void *cb_arg)</td></tr>
<tr class="memdesc:ga3729e80758b35ee2a2224a62a43c99f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the driver when the BSP Control Port (cp) write transaction completes.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga3729e80758b35ee2a2224a62a43c99f8">More...</a><br /></td></tr>
<tr class="separator:ga3729e80758b35ee2a2224a62a43c99f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ecb0de55d96200881e7c30999b3aee4"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga9ecb0de55d96200881e7c30999b3aee4">cs40l25_private_functions_t::irq_callback</a> )(uint32_t status, void *cb_arg)</td></tr>
<tr class="memdesc:ga9ecb0de55d96200881e7c30999b3aee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the driver when the CS40L25 INTb GPIO drops low.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga9ecb0de55d96200881e7c30999b3aee4">More...</a><br /></td></tr>
<tr class="separator:ga9ecb0de55d96200881e7c30999b3aee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bde41f4c248d03a08ed8882e7031659"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga7bde41f4c248d03a08ed8882e7031659">cs40l25_private_functions_t::read_reg</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, uint32_t addr, uint32_t *val, bool is_blocking)</td></tr>
<tr class="memdesc:ga7bde41f4c248d03a08ed8882e7031659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the contents of a single register/memory address.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga7bde41f4c248d03a08ed8882e7031659">More...</a><br /></td></tr>
<tr class="separator:ga7bde41f4c248d03a08ed8882e7031659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c6a4e5a9344c10243f78eb07cf59e6f"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga0c6a4e5a9344c10243f78eb07cf59e6f">cs40l25_private_functions_t::write_reg</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, uint32_t addr, uint32_t val, bool is_blocking)</td></tr>
<tr class="memdesc:ga0c6a4e5a9344c10243f78eb07cf59e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the contents of a single register/memory address.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga0c6a4e5a9344c10243f78eb07cf59e6f">More...</a><br /></td></tr>
<tr class="separator:ga0c6a4e5a9344c10243f78eb07cf59e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02bce945e25f52164a2ec1d956755c12"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga02bce945e25f52164a2ec1d956755c12">cs40l25_private_functions_t::reset_sm</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td></tr>
<tr class="memdesc:ga02bce945e25f52164a2ec1d956755c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset State Machine.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga02bce945e25f52164a2ec1d956755c12">More...</a><br /></td></tr>
<tr class="separator:ga02bce945e25f52164a2ec1d956755c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad398817f3d0a2fe76784fefe707d7d98"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gad398817f3d0a2fe76784fefe707d7d98">cs40l25_private_functions_t::boot_sm</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td></tr>
<tr class="memdesc:gad398817f3d0a2fe76784fefe707d7d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot State Machine.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gad398817f3d0a2fe76784fefe707d7d98">More...</a><br /></td></tr>
<tr class="separator:gad398817f3d0a2fe76784fefe707d7d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1cd49b58c58500e76bc60dac3c8091b"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gad1cd49b58c58500e76bc60dac3c8091b">cs40l25_private_functions_t::power_up_sm</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td></tr>
<tr class="memdesc:gad1cd49b58c58500e76bc60dac3c8091b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power Up State Machine.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gad1cd49b58c58500e76bc60dac3c8091b">More...</a><br /></td></tr>
<tr class="separator:gad1cd49b58c58500e76bc60dac3c8091b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb4e736ee4fe8a367b0e856a6e1f44b7"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gafb4e736ee4fe8a367b0e856a6e1f44b7">cs40l25_private_functions_t::power_down_sm</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td></tr>
<tr class="memdesc:gafb4e736ee4fe8a367b0e856a6e1f44b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power Down State Machine.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gafb4e736ee4fe8a367b0e856a6e1f44b7">More...</a><br /></td></tr>
<tr class="separator:gafb4e736ee4fe8a367b0e856a6e1f44b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc204ba869f6d3704a03bcc889c9ad2"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gabdc204ba869f6d3704a03bcc889c9ad2">cs40l25_private_functions_t::configure_sm</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td></tr>
<tr class="memdesc:gabdc204ba869f6d3704a03bcc889c9ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure State Machine.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gabdc204ba869f6d3704a03bcc889c9ad2">More...</a><br /></td></tr>
<tr class="separator:gabdc204ba869f6d3704a03bcc889c9ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece73e35801079d40049a54f5f6e4cfb"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaece73e35801079d40049a54f5f6e4cfb">cs40l25_private_functions_t::field_access_sm</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td></tr>
<tr class="memdesc:gaece73e35801079d40049a54f5f6e4cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Field Access State Machine.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaece73e35801079d40049a54f5f6e4cfb">More...</a><br /></td></tr>
<tr class="separator:gaece73e35801079d40049a54f5f6e4cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb339b75e75d9ebc71ff38a5e57f9df1"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gacb339b75e75d9ebc71ff38a5e57f9df1">cs40l25_private_functions_t::calibration_sm</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td></tr>
<tr class="memdesc:gacb339b75e75d9ebc71ff38a5e57f9df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibration State Machine.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gacb339b75e75d9ebc71ff38a5e57f9df1">More...</a><br /></td></tr>
<tr class="separator:gacb339b75e75d9ebc71ff38a5e57f9df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9d85d7b5700cb6edb7664f172486cc"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga6c9d85d7b5700cb6edb7664f172486cc">cs40l25_private_functions_t::get_dsp_status_sm</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td></tr>
<tr class="memdesc:ga6c9d85d7b5700cb6edb7664f172486cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DSP Status State Machine.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga6c9d85d7b5700cb6edb7664f172486cc">More...</a><br /></td></tr>
<tr class="separator:ga6c9d85d7b5700cb6edb7664f172486cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad4520b12543853d586c7b11436044c9"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaad4520b12543853d586c7b11436044c9">cs40l25_private_functions_t::event_sm</a> )(void *driver)</td></tr>
<tr class="memdesc:gaad4520b12543853d586c7b11436044c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event Handler State Machine.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaad4520b12543853d586c7b11436044c9">More...</a><br /></td></tr>
<tr class="separator:gaad4520b12543853d586c7b11436044c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48729a8fb53697de8a3b2901449e5181"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga48729a8fb53697de8a3b2901449e5181">cs40l25_private_functions_t::get_errata</a> )(uint32_t devid, uint32_t revid, const uint32_t **errata)</td></tr>
<tr class="memdesc:ga48729a8fb53697de8a3b2901449e5181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointer to correct errata based on DEVID/REVID.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga48729a8fb53697de8a3b2901449e5181">More...</a><br /></td></tr>
<tr class="separator:ga48729a8fb53697de8a3b2901449e5181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8cfaf2f3974a4e7e40f9506bbefff5b"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaa8cfaf2f3974a4e7e40f9506bbefff5b">cs40l25_private_functions_t::cp_bulk_read</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, uint32_t addr, uint32_t length)</td></tr>
<tr class="memdesc:gaa8cfaf2f3974a4e7e40f9506bbefff5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads contents from a consecutive number of memory addresses.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaa8cfaf2f3974a4e7e40f9506bbefff5b">More...</a><br /></td></tr>
<tr class="separator:gaa8cfaf2f3974a4e7e40f9506bbefff5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3787ab6aede0d1ea32755b2aacb45bff"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga3787ab6aede0d1ea32755b2aacb45bff">cs40l25_private_functions_t::cp_bulk_write</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, uint32_t addr, uint8_t *bytes, uint32_t length)</td></tr>
<tr class="memdesc:ga3787ab6aede0d1ea32755b2aacb45bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes from byte array to consecutive number of Control Port memory addresses.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga3787ab6aede0d1ea32755b2aacb45bff">More...</a><br /></td></tr>
<tr class="separator:ga3787ab6aede0d1ea32755b2aacb45bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac55bb0ebae20fb002fc8858ee80be8f"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaac55bb0ebae20fb002fc8858ee80be8f">cs40l25_private_functions_t::validate_boot_config</a> )(<a class="el" href="structcs40l25__boot__config__t.html">cs40l25_boot_config_t</a> *config, bool is_fw_boot, bool is_coeff_boot, bool is_cal_boot)</td></tr>
<tr class="memdesc:gaac55bb0ebae20fb002fc8858ee80be8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the boot configuration provided by the BSP.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaac55bb0ebae20fb002fc8858ee80be8f">More...</a><br /></td></tr>
<tr class="separator:gaac55bb0ebae20fb002fc8858ee80be8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aeda5eada72b4d3e59872505543f706"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga7aeda5eada72b4d3e59872505543f706">cs40l25_private_functions_t::control_q_copy</a> )(void *from, void *to)</td></tr>
<tr class="memdesc:ga7aeda5eada72b4d3e59872505543f706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements 'copy' method for Control Request Queue contents.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga7aeda5eada72b4d3e59872505543f706">More...</a><br /></td></tr>
<tr class="separator:ga7aeda5eada72b4d3e59872505543f706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf841d40a07cb97ab15037ff964226bd"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gadf841d40a07cb97ab15037ff964226bd">cs40l25_private_functions_t::is_control_valid</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td></tr>
<tr class="memdesc:gadf841d40a07cb97ab15037ff964226bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the currently processed Control Request is valid for the current state of the driver.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gadf841d40a07cb97ab15037ff964226bd">More...</a><br /></td></tr>
<tr class="separator:gadf841d40a07cb97ab15037ff964226bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e3821dab7d2277e65e7fda6b452b9a7"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga7e3821dab7d2277e65e7fda6b452b9a7">cs40l25_private_functions_t::load_control</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td></tr>
<tr class="memdesc:ga7e3821dab7d2277e65e7fda6b452b9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load new Control Request to be processed.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga7e3821dab7d2277e65e7fda6b452b9a7">More...</a><br /></td></tr>
<tr class="separator:ga7e3821dab7d2277e65e7fda6b452b9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd4b833b750e811a9da3add8d9e10cc0"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gafd4b833b750e811a9da3add8d9e10cc0">cs40l25_private_functions_t::irq_to_event_id</a> )(uint32_t *<a class="el" href="cs40l25_8c.html#a93ed7ca914fe1948b5d02bdf1b1c0083">irq_statuses</a>)</td></tr>
<tr class="memdesc:gafd4b833b750e811a9da3add8d9e10cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps IRQ Flag to Event ID passed to BSP.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gafd4b833b750e811a9da3add8d9e10cc0">More...</a><br /></td></tr>
<tr class="separator:gafd4b833b750e811a9da3add8d9e10cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44c55755dadfd90ef7290ee04867b336"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga44c55755dadfd90ef7290ee04867b336">cs40l25_private_functions_t::apply_configs</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td></tr>
<tr class="memdesc:ga44c55755dadfd90ef7290ee04867b336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply all driver one-time configurations to corresponding Control Port register/memory addresses.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga44c55755dadfd90ef7290ee04867b336">More...</a><br /></td></tr>
<tr class="separator:ga44c55755dadfd90ef7290ee04867b336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdea562b30695ece7ea7ad2283b034c4"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gacdea562b30695ece7ea7ad2283b034c4">cs40l25_private_functions_t::is_mixer_source_used</a> )(<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, uint8_t source)</td></tr>
<tr class="memdesc:gacdea562b30695ece7ea7ad2283b034c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks all hardware mixer source selections for a specific source.  <a href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gacdea562b30695ece7ea7ad2283b034c4">More...</a><br /></td></tr>
<tr class="separator:gacdea562b30695ece7ea7ad2283b034c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf021d5fceee29eeabf9ff5ea1d40dd33"><td class="memItemLeft" align="right" valign="top"><a id="gaf021d5fceee29eeabf9ff5ea1d40dd33"></a>
<a class="el" href="structcs40l25__functions__t.html">cs40l25_functions_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#gaf021d5fceee29eeabf9ff5ea1d40dd33">cs40l25_functions_g</a></td></tr>
<tr class="memdesc:gaf021d5fceee29eeabf9ff5ea1d40dd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Public API implementation. <br /></td></tr>
<tr class="separator:gaf021d5fceee29eeabf9ff5ea1d40dd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10ee8273b1a1db5e556e889ad14322c0"><td class="memItemLeft" align="right" valign="top"><a id="ga10ee8273b1a1db5e556e889ad14322c0"></a>
<a class="el" href="structcs40l25__private__functions__t.html">cs40l25_private_functions_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga10ee8273b1a1db5e556e889ad14322c0">cs40l25_private_functions_g</a></td></tr>
<tr class="memdesc:ga10ee8273b1a1db5e556e889ad14322c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Private API implementation. <br /></td></tr>
<tr class="separator:ga10ee8273b1a1db5e556e889ad14322c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Generic states used for all child state machines. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcs40l25__sm__t.html" title="Data structure describing driver control state machine implementation.">cs40l25_sm_t</a> member state </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaf636142b8de71f4a24a729bd9c2c9081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf636142b8de71f4a24a729bd9c2c9081">&#9670;&nbsp;</a></span>CS40L25_CONTROL_REQUESTS_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CS40L25_CONTROL_REQUESTS_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of Control Request Queue. </p>
<dl class="section attention"><dt>Attention</dt><dd>The system designer should size this queue to handle the maximum number of Control Requests the system could possibly send to the driver before ability to process. </dd></dl>

</div>
</div>
<a id="ga5b97233afe3013afc65fdce724145df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b97233afe3013afc65fdce724145df8">&#9670;&nbsp;</a></span>CS40L25_CP_READ_BUFFER_LENGTH_BYTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CS40L25_CP_READ_BUFFER_LENGTH_BYTES</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Length of Control Port Read buffer. </p>
<dl class="section attention"><dt>Attention</dt><dd>The BSP is required to allocate a buffer of this length before initializing the driver. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga44fbc7618e0385fff020c153a1651c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44fbc7618e0385fff020c153a1651c71">&#9670;&nbsp;</a></span>cs40l25_control_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* cs40l25_control_callback_t) (uint8_t id, uint32_t status, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function pointer to Control Request Callback. </p>
<p>This callback will be registered when the Control Request is requested, i.e. via control(), boot() API.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcs40l25__functions__t.html" title="Driver public API.">cs40l25_functions_t</a> member control</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Control ID just completed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Status of Control Request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Callback arg registered by upper layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga0b78156f6addb3f1db4918f59f2ac6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b78156f6addb3f1db4918f59f2ac6c9">&#9670;&nbsp;</a></span>cs40l25_notification_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* cs40l25_notification_callback_t) (uint32_t event_flags, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function pointer to Notification Callback. </p>
<p>This callback will be registered at driver configuration. This callback is called whenever the driver has detected a significant event has occurred, such as an over-temperature condition.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcs40l25__functions__t.html" title="Driver public API.">cs40l25_functions_t</a> member configure</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_flags</td><td>Flags to indicate which events have occurred </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Callback arg registered by upper layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a id="ga79a15a64c3002ca69a17d65b1df14149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79a15a64c3002ca69a17d65b1df14149">&#9670;&nbsp;</a></span>cs40l25_sm_fp_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t(* cs40l25_sm_fp_t) (void *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function pointer to driver control state machine implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>General driver API call status </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga44c55755dadfd90ef7290ee04867b336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44c55755dadfd90ef7290ee04867b336">&#9670;&nbsp;</a></span>apply_configs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::apply_configs) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply all driver one-time configurations to corresponding Control Port register/memory addresses. </p>
<p>Performs the following:</p><ul>
<li>applies all configurations from <a class="el" href="structcs40l25__audio__config__t.html" title="Collection of audio-related configurations.">cs40l25_audio_config_t</a></li>
<li>applies all configurations from <a class="el" href="structcs40l25__amp__config__t.html" title="Amplifier-related configurations.">cs40l25_amp_config_t</a></li>
<li>based on configurations, sets/clears hardware block enables</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if any configuration parameters are outside bounds or do not result in proper register bit-field encoding</li>
<li>CS40L25_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gacf3acbe80b123d357c9c7a48e69f3208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf3acbe80b123d357c9c7a48e69f3208">&#9670;&nbsp;</a></span>boot</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_functions_t::boot) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, bool cal_boot, <a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga44fbc7618e0385fff020c153a1651c71">cs40l25_control_callback_t</a> cb, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boot the CS40L25. </p>
<p>Boot may include stepping through the following state machines:</p><ul>
<li>Boot SM - load a HALO DSP FW image and COEFF image</li>
<li>Configure SM - apply the driver configuration to the CS40L25 register file</li>
</ul>
<p>This function is essentially an alias for multiple calls to cs40l25_control - it submits Control Requests for the controls above that apply to the current driver configuration.</p>
<dl class="section attention"><dt>Attention</dt><dd>It should be noted that the callback <b>cb</b> will be called upon completion (either successful or unsuccessful) of <b>each</b> Control Request when booting. Thus the caller could get the callback called for BOOT and CONFIGURE controls.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cal_boot</td><td>Boolean to specify whether this is a calibration boot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback for completion of each control stage of boot process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>Pointer to argument to use for callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if any submission of Control Request failed</li>
<li>CS40L25_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad398817f3d0a2fe76784fefe707d7d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad398817f3d0a2fe76784fefe707d7d98">&#9670;&nbsp;</a></span>boot_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::boot_sm) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boot State Machine. </p>
<p>This state machine loads FW and COEFF images into the CS40L25 HALO DSP memory regions. Completing the state machine results in the driver transition to DSP_STANDBY state, or the CAL_STANDBY state for the calibration FW. The state machine design is documented in the Boot State Diagram found in the Driver Tech Note.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS40L25_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Boot State Diagram </dd></dl>

</div>
</div>
<a id="gab2b2830798a2cd2da8c82af686d516fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2b2830798a2cd2da8c82af686d516fd">&#9670;&nbsp;</a></span>calibrate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_functions_t::calibrate) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, uint32_t calib_type, <a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga44fbc7618e0385fff020c153a1651c71">cs40l25_control_callback_t</a> cb, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calibrate the HALO DSP Protection Algorithm. </p>
<p>This performs the calibration procedure for Prince Haptic Control firmwares. This calibration information (<a class="el" href="structcs40l25__calibration__t.html" title="State of HALO FW Calibration.">cs40l25_calibration_t</a>) will be saved in the driver state and applied during subsequent boots of the part. This calibration information will be available to the driver until the driver is re-initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">calib_type</td><td>The calibration type to be performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback for completion of each control stage of boot process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>Pointer to argument to use for callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if submission of Control Request failed</li>
<li>CS40L25_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcs40l25__calibration__t.html" title="State of HALO FW Calibration.">cs40l25_calibration_t</a> </dd></dl>

</div>
</div>
<a id="gacb339b75e75d9ebc71ff38a5e57f9df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb339b75e75d9ebc71ff38a5e57f9df1">&#9670;&nbsp;</a></span>calibration_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::calibration_sm) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calibration State Machine. </p>
<p>This state machine performs the Calibration sequence for Prince Haptic Control firmwares. Completing the state machine does not result in any driver state change. The state machine design is documented in the Calibration State Diagram found in the Driver Tech Note.</p>
<dl class="section attention"><dt>Attention</dt><dd>The Calibration sequence can only be successfully performed under the following conditions:<ul>
<li>while the driver is in POWER_UP state</li>
<li>after HALO DSP FW and Calibration COEFF has been loaded</li>
<li>while the ASP is clocked with valid I2S clocks</li>
<li>while the ASP is being sourced with Silence</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS40L25_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Calibration State Diagram </dd>
<dd>
<a class="el" href="structcs40l25__calibration__t.html" title="State of HALO FW Calibration.">cs40l25_calibration_t</a> </dd></dl>

</div>
</div>
<a id="ga63d523c9c110048551ac56e6b8f20c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63d523c9c110048551ac56e6b8f20c4c">&#9670;&nbsp;</a></span>configure</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_functions_t::configure) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, <a class="el" href="structcs40l25__config__t.html">cs40l25_config_t</a> *config)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures driver state/handle. </p>
<p>Including the following:</p><ul>
<li>Applies all one-time configurations to the driver state</li>
<li>Registers the IRQ Callback for INTb GPIO with the BSP</li>
<li>Applies calibration data (if valid) to the driver state</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to driver configuration data structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if any pointers are NULL</li>
<li>CS40L25_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabdc204ba869f6d3704a03bcc889c9ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdc204ba869f6d3704a03bcc889c9ad2">&#9670;&nbsp;</a></span>configure_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::configure_sm) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure State Machine. </p>
<p>This state machine performs all CS40L25 configuration required after Reset and DSP Boot. Completing the state machine does not result in any driver state change. Although the configuration should almost always be performed when the driver is in STANDBY or DSP_STANDBY state, it is not prohibited. The state machine design is documented in the Configure State Diagram found in the Driver Tech Note.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS40L25_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Configure State Diagram </dd>
<dd>
<a class="el" href="cs40l25_8c.html#ad00cd13ec44b93734adf6d4c9a482065" title="Apply all driver one-time configurations to corresponding Control Port register/memory addresses.">cs40l25_apply_configs()</a> </dd></dl>

</div>
</div>
<a id="gaa2f1a666e1c4a785ed0b3bbdfd9d189a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2f1a666e1c4a785ed0b3bbdfd9d189a">&#9670;&nbsp;</a></span>control</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_functions_t::control) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, <a class="el" href="structcs40l25__control__request__t.html">cs40l25_control_request_t</a> req)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a Control Request to the driver. </p>
<p>Caller will initialize a <a class="el" href="structcs40l25__control__request__t.html" title="Data structure to describe a Control Request.">cs40l25_control_request_t</a> 'req' based on the control it wishes to access. This request will then be added to the Control Request Queue, and the callback given in 'req' will be called once either:</p><ul>
<li>the Control Request has completed successfully</li>
<li>there was an ERROR when executing the Control Request</li>
<li>the Control Request is invalid for the current driver state</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>data structure for control request <b>passed</b> by value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if Control Request ID is invalid OR if insertion into Control Request Queue failed</li>
<li>CS40L25_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcs40l25__control__request__t.html" title="Data structure to describe a Control Request.">cs40l25_control_request_t</a> </dd></dl>

</div>
</div>
<a id="ga7aeda5eada72b4d3e59872505543f706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aeda5eada72b4d3e59872505543f706">&#9670;&nbsp;</a></span>control_q_copy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* cs40l25_private_functions_t::control_q_copy) (void *from, void *to)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements 'copy' method for Control Request Queue contents. </p>
<p>Initialization of <a class="el" href="structf__queue__t.html" title="Queue handling data structure.">f_queue_t</a> requires a 'copy' method for copying the data type that comprises the elements of the queue. This implements the method for the queue used for Control Requests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>pointer to element to copy contents from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>pointer of empty element to which the contents should be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>false if either pointers are null</li>
<li>true otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="f__queue_8h.html#abedd0d023ee1ed717ab173baae6a2d3b" title="Abstract method for copying from one queue element type to another.">f_queue_copy</a> </dd>
<dd>
<a class="el" href="structf__queue__if__t.html" title="Fixed Queue public API.">f_queue_if_t</a> member initialize </dd></dl>

</div>
</div>
<a id="gaa8cfaf2f3974a4e7e40f9506bbefff5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8cfaf2f3974a4e7e40f9506bbefff5b">&#9670;&nbsp;</a></span>cp_bulk_read</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::cp_bulk_read) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, uint32_t addr, uint32_t length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads contents from a consecutive number of memory addresses. </p>
<p>Starting at 'addr', this will read 'length' number of 32-bit values into the BSP-allocated buffer from the control port. This bulk read will place contents into the BSP buffer starting at the 4th byte address. Bytes 0-3 in the buffer are reserved for non-bulk reads (i.e. calls to cs40l25_read_reg). This control port call only supports non-blocking calls. This function also only supports I2C transactions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>32-bit address to be read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>number of memory addresses (i.e. 32-bit words) to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if the call to BSP failed, or if 'length' exceeds the size of BSP buffer</li>
<li>CS40L25_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Contains platform-dependent code. </dd></dl>

</div>
</div>
<a id="ga3787ab6aede0d1ea32755b2aacb45bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3787ab6aede0d1ea32755b2aacb45bff">&#9670;&nbsp;</a></span>cp_bulk_write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::cp_bulk_write) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, uint32_t addr, uint8_t *bytes, uint32_t length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes from byte array to consecutive number of Control Port memory addresses. </p>
<p>This control port call only supports non-blocking calls. This function also only supports I2C transactions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>32-bit address to be read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>pointer to array of bytes to write via Control Port bus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if the call to BSP failed</li>
<li>CS40L25_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Contains platform-dependent code. </dd></dl>

</div>
</div>
<a id="gaaf971a22da1b6145717662b82e91a8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf971a22da1b6145717662b82e91a8cf">&#9670;&nbsp;</a></span>cp_read_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* cs40l25_private_functions_t::cp_read_callback) (uint32_t status, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the driver when the BSP Control Port (cp) read transaction completes. </p>
<p>This callback is given as a parameter for all non-blocking calls to the following API in <a class="el" href="structbsp__driver__if__t.html" title="BSP-to-Driver public API.">bsp_driver_if_t</a>.</p><ul>
<li>i2c_read_repeated_start</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Currently, the BSP and driver only support I2C transactions.</dd></dl>
<p>The primary task of this callback is to set flags in either the flag cache for the currently processed Control Request state machine, or the Event Handler state machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Status of the asynchronous call to BSP Control Port read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>A pointer to callback argument registered. For the driver, this arg is used for a pointer to the driver state <a class="el" href="structcs40l25__t.html" title="Driver state data structure.">cs40l25_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structbsp__driver__if__t.html" title="BSP-to-Driver public API.">bsp_driver_if_t</a> member i2c_read_repeated_start. </dd>
<dd>
<a class="el" href="bsp__driver__if_8h.html#a9da53d6fb2687f1afc4fe77a6d1a101f" title="Callback type for BSP-to-Driver callbacks.">bsp_callback_t</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Contains platform-dependent code. </dd></dl>

</div>
</div>
<a id="ga3729e80758b35ee2a2224a62a43c99f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3729e80758b35ee2a2224a62a43c99f8">&#9670;&nbsp;</a></span>cp_write_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* cs40l25_private_functions_t::cp_write_callback) (uint32_t status, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the driver when the BSP Control Port (cp) write transaction completes. </p>
<p>This callback is given as a parameter for all non-blocking calls to the following API in <a class="el" href="structbsp__driver__if__t.html" title="BSP-to-Driver public API.">bsp_driver_if_t</a>.</p><ul>
<li>i2c_write</li>
<li>i2c_db_write</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Currently, the BSP and driver only support I2C transactions.</dd></dl>
<p>The primary task of this callback is to set flags in either the flag cache for the currently processed Control Request state machine, or the Event Handler state machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Status of the asynchronous call to BSP Control Port write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>A pointer to callback argument registered. For the driver, this arg is used for a pointer to the driver state <a class="el" href="structcs40l25__t.html" title="Driver state data structure.">cs40l25_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structbsp__driver__if__t.html" title="BSP-to-Driver public API.">bsp_driver_if_t</a> member i2c_write, i2c_db_write. </dd>
<dd>
<a class="el" href="bsp__driver__if_8h.html#a9da53d6fb2687f1afc4fe77a6d1a101f" title="Callback type for BSP-to-Driver callbacks.">bsp_callback_t</a> </dd></dl>

</div>
</div>
<a id="gaad4520b12543853d586c7b11436044c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad4520b12543853d586c7b11436044c9">&#9670;&nbsp;</a></span>event_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::event_sm) (void *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event Handler State Machine. </p>
<p>This state machine performs all steps to handle IRQ and other asynchronous events the driver is aware of, resulting in calling of the notification callback (cs40l25_notification_callback_t).</p>
<p>Beginning the state machine results in transition of driver <b>mode</b> from HANDLING_CONTROLS to HANDLING_EVENTS, while completing the state machine will result in transition of driver <b>mode</b> from HANDLING_EVENTS to HANDLING_CONTROLS in <a class="el" href="cs40l25_8c.html#a72628faf4f0b3cfbd93b110f99ab6e3e" title="Processes driver state machines.">cs40l25_process()</a>. The state machine design is documented in the Event Handler State Diagram found in the Driver Tech Note.</p>
<p>If there are any IRQ events that include Speaker-Safe Mode Errors or Boost-related events, then the procedure outlined in the Datasheet Section 4.16.1.1 is implemented here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS40L25_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Event Handler State Diagram </dd>
<dd>
<a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga0b78156f6addb3f1db4918f59f2ac6c9" title="Function pointer to Notification Callback.">cs40l25_notification_callback_t</a> </dd></dl>

</div>
</div>
<a id="gaece73e35801079d40049a54f5f6e4cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaece73e35801079d40049a54f5f6e4cfb">&#9670;&nbsp;</a></span>field_access_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::field_access_sm) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Field Access State Machine. </p>
<p>This state machine performs actions required to do a Get/Set of a Control Port register or HALO DSP Memory bit-field. Completing the state machine does not result in any driver state change. The state machine design is documented in the Field Access State Diagram found in the Driver Tech Note.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS40L25_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Field Access State Diagram </dd>
<dd>
<a class="el" href="structcs40l25__field__accessor__t.html" title="Data structure to describe a field to read via the Field Access SM.">cs40l25_field_accessor_t</a> </dd></dl>

</div>
</div>
<a id="ga6c9d85d7b5700cb6edb7664f172486cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c9d85d7b5700cb6edb7664f172486cc">&#9670;&nbsp;</a></span>get_dsp_status_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::get_dsp_status_sm) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get DSP Status State Machine. </p>
<p>This state machine performs all register/memory field address reads to get the current HALO DSP status. Since some statuses are only determined by observing changes in values of a given field, the fields are read once, then after a delay of 10 milliseconds, are read a second time to observe changes. Completing the state machine does not result in any driver state change. The state machine design is documented in the Get DSP Status State Diagram found in the Driver Tech Note.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS40L25_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Get DSP Status State Diagram </dd>
<dd>
<a class="el" href="structcs40l25__dsp__status__t.html" title="Status of HALO FW.">cs40l25_dsp_status_t</a> </dd></dl>

</div>
</div>
<a id="ga48729a8fb53697de8a3b2901449e5181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48729a8fb53697de8a3b2901449e5181">&#9670;&nbsp;</a></span>get_errata</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::get_errata) (uint32_t devid, uint32_t revid, const uint32_t **errata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets pointer to correct errata based on DEVID/REVID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devid</td><td>DEVID read from CS40L25_SW_RESET_DEVID_REG </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">revid</td><td>REVID read from CS40L25_SW_RESET_REVID_REG </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errata</td><td>Pointer to array of uint32_t implementing errata</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL corresponding errata not found</li>
<li>CS40L25_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabe90b157dc3e0351bbd034e6bdca36d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe90b157dc3e0351bbd034e6bdca36d4">&#9670;&nbsp;</a></span>initialize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_functions_t::initialize) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize driver state/handle. </p>
<p>Sets all driver state members to 0, and initializes Control Request Queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if call to <a class="el" href="structf__queue__if__t.html" title="Fixed Queue public API.">f_queue_if_t</a> fails</li>
<li>CS40L25_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9ecb0de55d96200881e7c30999b3aee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ecb0de55d96200881e7c30999b3aee4">&#9670;&nbsp;</a></span>irq_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* cs40l25_private_functions_t::irq_callback) (uint32_t status, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the driver when the CS40L25 INTb GPIO drops low. </p>
<p>This callback is registered with the BSP in the register_gpio_cb() API call.</p>
<p>The primary task of this callback is to transition the driver mode from CS40L25_MODE_HANDLING_CONTROLS to CS40L25_MODE_HANDLING_EVENTS, in order to start processing the Event Handler state machine. It also resets the Event Handler state machine, if it was not currently being processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Status of the asynchronous call to BSP Control Port write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>A pointer to callback argument registered. For the driver, this arg is used for a pointer to the driver state <a class="el" href="structcs40l25__t.html" title="Driver state data structure.">cs40l25_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structbsp__driver__if__t.html" title="BSP-to-Driver public API.">bsp_driver_if_t</a> member register_gpio_cb. </dd>
<dd>
<a class="el" href="bsp__driver__if_8h.html#a9da53d6fb2687f1afc4fe77a6d1a101f" title="Callback type for BSP-to-Driver callbacks.">bsp_callback_t</a> </dd></dl>

</div>
</div>
<a id="gafd4b833b750e811a9da3add8d9e10cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd4b833b750e811a9da3add8d9e10cc0">&#9670;&nbsp;</a></span>irq_to_event_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::irq_to_event_id) (uint32_t *<a class="el" href="cs40l25_8c.html#a93ed7ca914fe1948b5d02bdf1b1c0083">irq_statuses</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps IRQ Flag to Event ID passed to BSP. </p>
<p>Allows for abstracting driver events relayed to BSP away from IRQ flags, to allow the possibility that multiple IRQ flags correspond to a single event to relay.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">irq_statuses</td><td>pointer to array of 32-bit words from IRQ1_IRQ1_EINT_*_REG registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32-bit word with CS40L25_EVENT_FLAG_* set for each event detected</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_s40_l25___e_v_e_n_t___f_l_a_g__.html" title="Flags passed to Notification Callback to notify BSP of specific driver events.">CS40L25_EVENT_FLAG_</a> </dd></dl>

</div>
</div>
<a id="gadf841d40a07cb97ab15037ff964226bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf841d40a07cb97ab15037ff964226bd">&#9670;&nbsp;</a></span>is_control_valid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::is_control_valid) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that the currently processed Control Request is valid for the current state of the driver. </p>
<p>Since the state of the driver is asynchronous to the Control Request currently being processed, cs40l25_process needs to check whether the request is valid for the current state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if no request is being processed, or if current request is invalid</li>
<li>CS40L25_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gacdea562b30695ece7ea7ad2283b034c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdea562b30695ece7ea7ad2283b034c4">&#9670;&nbsp;</a></span>is_mixer_source_used</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* cs40l25_private_functions_t::is_mixer_source_used) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, uint8_t source)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks all hardware mixer source selections for a specific source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Mixer source to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>true Mixer source 'source' is used</li>
<li>false Mixer source 'source' is not used</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_s40_l25___i_n_p_u_t___s_r_c__.html" title="Settings for MIXER Source Values.">CS40L25_INPUT_SRC_</a> </dd></dl>

</div>
</div>
<a id="ga7e3821dab7d2277e65e7fda6b452b9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e3821dab7d2277e65e7fda6b452b9a7">&#9670;&nbsp;</a></span>load_control</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::load_control) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load new Control Request to be processed. </p>
<p>Removes next element from Control Request Queue and initializes the corresponding state machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if ID for new Control Request is not valid</li>
<li>CS40L25_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga233b14740e59b9641955a68ee76f5470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga233b14740e59b9641955a68ee76f5470">&#9670;&nbsp;</a></span>mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cs40l25_t::mode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General driver mode -. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_s40_l25___m_o_d_e__.html" title="Mode of the driver.">CS40L25_MODE_</a> </dd></dl>

</div>
</div>
<a id="ga37fa8d396ac536e9780fc567370ddddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37fa8d396ac536e9780fc567370ddddc">&#9670;&nbsp;</a></span>power</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_functions_t::power) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, uint32_t power_state, <a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga44fbc7618e0385fff020c153a1651c71">cs40l25_control_callback_t</a> cb, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the power state. </p>
<p>This submits a Control Request to either Power Up or Power Down the CS40L25. Although there is no checking here for whether the request is invalid (i.e. Power Down when the driver state is already STANDBY), this checking will be performed once the request is loaded in <a class="el" href="cs40l25_8c.html#a72628faf4f0b3cfbd93b110f99ab6e3e" title="Processes driver state machines.">cs40l25_process()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">power_state</td><td>New power state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback for completion of each control stage of boot process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>Pointer to argument to use for callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if submission of Control Request failed</li>
<li>CS40L25_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gafb4e736ee4fe8a367b0e856a6e1f44b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb4e736ee4fe8a367b0e856a6e1f44b7">&#9670;&nbsp;</a></span>power_down_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::power_down_sm) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power Down State Machine. </p>
<p>This state machine performs all necessary steps to transition the CS40L25 to be in Standby power mode. Completing the state machine results in the driver transition to STANDBY, DSP_STANDBY or CAL_STANDBY state. The state machine design is documented in the Power Down State Diagram found in the Driver Tech Note.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS40L25_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Power Down State Diagram </dd></dl>

</div>
</div>
<a id="gad1cd49b58c58500e76bc60dac3c8091b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1cd49b58c58500e76bc60dac3c8091b">&#9670;&nbsp;</a></span>power_up_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::power_up_sm) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power Up State Machine. </p>
<p>This state machine performs all necessary steps to transition the CS40L25 to be ready to process haptic events. Completing the state machine results in the driver transition to the DSP_POWER_UP state. The state machine design is documented in the Power Up State Diagram found in the Driver Tech Note.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS40L25_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Power Up State Diagram </dd></dl>

</div>
</div>
<a id="ga1ea0a047dcf2a0b103d4c0607eba04fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ea0a047dcf2a0b103d4c0607eba04fb">&#9670;&nbsp;</a></span>process</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_functions_t::process) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes driver state machines. </p>
<p>This implements the 'CS40L25 Process Flowchart' found in the driver Tech Note. This includes:</p><ul>
<li>calling Event Handler SM if in HANDLING_EVENTS mode</li>
<li>calling current Control SM if in HANLDING_CONTROLS mode</li>
<li>loading new controls and checking validity per driver state</li>
<li>calling BSP callbacks upon completion of Control Requests</li>
<li>handling Control Request errors</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>if in UNCONFIGURED or ERROR state, returns CS40L25_STATUS_OK</li>
<li>else if in HANDLING_CONTROLS mode and not currently processing Control SM&lt; returns CS40L25_STATUS_OK</li>
<li>otherwise, returns status from any state machine executed (either Event Handler or Control SM)</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This MUST be placed either in baremetal or RTOS task while (1) </dd></dl>

</div>
</div>
<a id="ga7bde41f4c248d03a08ed8882e7031659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bde41f4c248d03a08ed8882e7031659">&#9670;&nbsp;</a></span>read_reg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::read_reg) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, uint32_t addr, uint32_t *val, bool is_blocking)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the contents of a single register/memory address. </p>
<p>The main purpose is to handle buffering and BSP calls required for reading a single memory address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>32-bit address to be read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">val</td><td>Pointer to register value read (only used for non-blocking calls) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_blocking</td><td>Indicates whether request is for blocking (true) or non-blocking (false) call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if the call to BSP failed</li>
<li>CS40L25_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Contains platform-dependent code. </dd></dl>

</div>
</div>
<a id="gac1ce5121caea077804edf4c2d6a8faa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1ce5121caea077804edf4c2d6a8faa1">&#9670;&nbsp;</a></span>refclk_sel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t cs40l25_clock_config_t::refclk_sel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clock source for REFCLK. </p>
<dl class="section see"><dt>See also</dt><dd>CS40L25_PLL_REFLCLK_SEL_ </dd></dl>

</div>
</div>
<a id="ga35c203ed780b02fd7331c0f3ce86c603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35c203ed780b02fd7331c0f3ce86c603">&#9670;&nbsp;</a></span>reset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_functions_t::reset) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, <a class="el" href="group___c_s40_l25___s_m___s_t_a_t_e__.html#ga44fbc7618e0385fff020c153a1651c71">cs40l25_control_callback_t</a> cb, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the CS40L25. </p>
<p>Reset will include stepping through the following state machine:</p><ul>
<li>Reset SM - toggle RESET GPIO, identify device</li>
</ul>
<p>This function is essentially an alias for a call to cs40l25_control</p>
<dl class="section attention"><dt>Attention</dt><dd>It should be noted that the callback <b>cb</b> will be called upon completion (either successful or unsuccessful) of the Reset Control Request when resetting.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback for completion of each control stage of reset process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>Pointer to argument to use for callback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if any submission of Control Request failed</li>
<li>CS40L25_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga02bce945e25f52164a2ec1d956755c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02bce945e25f52164a2ec1d956755c12">&#9670;&nbsp;</a></span>reset_sm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::reset_sm) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset State Machine. </p>
<p>This state machine performs all necessary steps to reset the CS40L25 and put it into POWER_UP state. The state machine design is documented in the Reset State Diagram found in the Driver Tech Note.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if state machine transitioned to ERROR state for any reason</li>
<li>CS40L25_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Driver Tech Note, Reset State Diagram </dd></dl>

</div>
</div>
<a id="ga6ad303e9a6f79190e69c869fa07a3a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ad303e9a6f79190e69c869fa07a3a3a">&#9670;&nbsp;</a></span>state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cs40l25_t::state</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General driver state -. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_s40_l25___s_t_a_t_e__.html" title="State of the driver.">CS40L25_STATE_</a> </dd></dl>

</div>
</div>
<a id="ga9507f9288e1030310c30486d45c52547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9507f9288e1030310c30486d45c52547">&#9670;&nbsp;</a></span>timer_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* cs40l25_private_functions_t::timer_callback) (uint32_t status, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the driver when the BSP Timer expires. </p>
<p>This callback is given as a parameter for all non-blocking calls to the set_timer() API in <a class="el" href="structbsp__driver__if__t.html" title="BSP-to-Driver public API.">bsp_driver_if_t</a>. Currently, the timer is only used for state machines handling Control Requests, so the only action required is to set the CS40L25_FLAGS_TIMEOUT for the state machine being currently processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Status of the asynchronous call to set_timer() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>A pointer to callback argument registered for set_timer(). For the driver, this arg is used for a pointer to the driver state <a class="el" href="structcs40l25__t.html" title="Driver state data structure.">cs40l25_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structbsp__driver__if__t.html" title="BSP-to-Driver public API.">bsp_driver_if_t</a> member set_timer. </dd>
<dd>
<a class="el" href="bsp__driver__if_8h.html#a9da53d6fb2687f1afc4fe77a6d1a101f" title="Callback type for BSP-to-Driver callbacks.">bsp_callback_t</a> </dd></dl>

</div>
</div>
<a id="gaac55bb0ebae20fb002fc8858ee80be8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac55bb0ebae20fb002fc8858ee80be8f">&#9670;&nbsp;</a></span>validate_boot_config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::validate_boot_config) (<a class="el" href="structcs40l25__boot__config__t.html">cs40l25_boot_config_t</a> *config, bool is_fw_boot, bool is_coeff_boot, bool is_cal_boot)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the boot configuration provided by the BSP. </p>
<p>According to 'is_fw_boot' and 'is_coeff_boot' flags, checks that all required pointers to boot/coeff images are not NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>pointer to boot configuration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_fw_boot</td><td>whether current action is booting FW; (true) is a FW boot action, (false) is NOT a FW boot action </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_coeff_boot</td><td>whether current action is booting COEFF; (true) is a COEFF boot action, (false) is NOT a COEFF boot action</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if 'config' is NULL, if any required block pointers are NULL</li>
<li>CS40L25_STATUS_OK otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0c6a4e5a9344c10243f78eb07cf59e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c6a4e5a9344c10243f78eb07cf59e6f">&#9670;&nbsp;</a></span>write_reg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* cs40l25_private_functions_t::write_reg) (<a class="el" href="structcs40l25__t.html">cs40l25_t</a> *driver, uint32_t addr, uint32_t val, bool is_blocking)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the contents of a single register/memory address. </p>
<p>The main purpose is to handle buffering and BSP calls required for writing a single memory address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">driver</td><td>Pointer to the driver state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>32-bit address to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>32-bit value to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_blocking</td><td>Indicates whether request is for blocking (true) or non-blocking (false) call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CS40L25_STATUS_FAIL if the call to BSP failed</li>
<li>CS40L25_STATUS_OK otherwise</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Contains platform-dependent code. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
